{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":0},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"55567cf4651a533c3c15d3df57ce2c389e11130d","modified":1572274182679},{"_id":"source/CNAME","hash":"70bbc165e2970472777e6fc52848822b725d53ab","modified":1540862404482},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1523677104000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1523677104000},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1523677104000},{"_id":"themes/next/.gitignore","hash":"0b5c2ffd41f66eb1849d6426ba8cf9649eeed329","modified":1523677104000},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1523677104000},{"_id":"themes/next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1523677104000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1523677104000},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1523677104000},{"_id":"themes/next/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1523677104000},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1523677104000},{"_id":"themes/next/README.cn.md","hash":"2c766b3369ed477bce134a5450dab45bef161504","modified":1523677104000},{"_id":"themes/next/README.md","hash":"8ce60ce578963eb4e1eb5e33e1efc2fc4779af9c","modified":1523677104000},{"_id":"themes/next/_config.yml","hash":"04e78d12c3edb135d904d61b313d3567181ae276","modified":1541663609545},{"_id":"themes/next/bower.json","hash":"0674f11d3d514e087a176da0e1d85c2286aa5fba","modified":1523677104000},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1523677104000},{"_id":"themes/next/package.json","hash":"036d3a1346203d2f1a3958024df7f74e7ac07bfe","modified":1523677104000},{"_id":"source/_posts/.DS_Store","hash":"943fd3a46cbb28d0dbbd4e60cbb1b3c90bf5175c","modified":1543908659252},{"_id":"source/_posts/BST.md","hash":"042afed90b0bd3a7fbda186e66951a56d184e542","modified":1543977724370},{"_id":"source/_posts/CycleList.md","hash":"af2e0ede756ce8e7a8704ac30c32c820e75a5ef0","modified":1543977746392},{"_id":"source/_posts/LSC-DP.md","hash":"ede10194bd33955af65a6e25391564891f87ca6f","modified":1564291221862},{"_id":"source/_posts/poet1-我会采更多的雏菊.md","hash":"80bab4184b77938fd590607a38e77c6f7655bb36","modified":1564411708026},{"_id":"source/_posts/pthreadThoughts.md","hash":"b6f0db33dfe038770d477b00e80476c368a13268","modified":1568129398798},{"_id":"source/_posts/rethinkOfMelloc.md","hash":"89fe8cfa6232a37f36a071e11ebdbd3d02b9c50c","modified":1555142910539},{"_id":"source/_posts/single-linklist.md","hash":"9d9ecedb64503583563f097dcec11f967282ed84","modified":1547607637242},{"_id":"source/_posts/start-from-now.md","hash":"8f05d6e920c7764f98ceb64a28bac2d904df9445","modified":1541125209833},{"_id":"source/about/index.md","hash":"cfcf12a16a06b515154d1223e6cea108845fe20f","modified":1541125669088},{"_id":"source/categories/index.md","hash":"5ee198e3c75ee4e9eef621e3c9ecc367204a774d","modified":1541124699034},{"_id":"source/tags/index.md","hash":"362dec0acc06109b72cdfdaeb6f50afbe3a50ce5","modified":1541125429101},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"3b5eafd32abb718e56ccf8d1cee0607ad8ce611d","modified":1523677104000},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"50d48c47162817a3810a9d9ad51104e83947419a","modified":1523677104000},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"902f627155a65099e0a37842ff396a58d0dc306f","modified":1523677104000},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1523677104000},{"_id":"themes/next/languages/de.yml","hash":"057e7df11ddeb1c8c15a5d7c5ff29430d725ec6b","modified":1523677104000},{"_id":"themes/next/languages/default.yml","hash":"44ef3f26917f467459326c2c8be2f73e4d947f35","modified":1523677104000},{"_id":"themes/next/languages/en.yml","hash":"7e680d9bb8f3a3a9d1ba1c9d312b3d257183dded","modified":1523677104000},{"_id":"themes/next/languages/fr-FR.yml","hash":"7e4eb7011b8feee641cfb11c6e73180b0ded1c0f","modified":1523677104000},{"_id":"themes/next/languages/id.yml","hash":"b5de1ea66dd9ef54cac9a1440eaa4e3f5fc011f5","modified":1523677104000},{"_id":"themes/next/languages/it.yml","hash":"aa595f2bda029f73ef7bfa104b4c55c3f4e9fb4c","modified":1523677104000},{"_id":"themes/next/languages/ja.yml","hash":"3c76e16fd19b262864475faa6854b718bc08c4d8","modified":1523677104000},{"_id":"themes/next/languages/ko.yml","hash":"ea5b46056e73ebcee121d5551627af35cbffc900","modified":1523677104000},{"_id":"themes/next/languages/nl-NL.yml","hash":"edca4f3598857dbc3cbf19ed412213329b6edd47","modified":1523677104000},{"_id":"themes/next/languages/pt-BR.yml","hash":"b1694ae766ed90277bcc4daca4b1cfa19cdcb72b","modified":1523677104000},{"_id":"themes/next/languages/pt.yml","hash":"44b61f2d085b827b507909a0b8f8ce31c6ef5d04","modified":1523677104000},{"_id":"themes/next/languages/ru.yml","hash":"98ec6f0b7183282e11cffc7ff586ceb82400dd75","modified":1523677104000},{"_id":"themes/next/languages/vi.yml","hash":"fd08d3c8d2c62965a98ac420fdaf95e54c25d97c","modified":1523677104000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"16ef56d0dea94638de7d200984c90ae56f26b4fe","modified":1523677104000},{"_id":"themes/next/languages/zh-hk.yml","hash":"9396f41ae76e4fef99b257c93c7354e661f6e0fa","modified":1523677104000},{"_id":"themes/next/languages/zh-tw.yml","hash":"50b71abb3ecc0686f9739e179e2f829cd074ecd9","modified":1523677104000},{"_id":"themes/next/layout/_layout.swig","hash":"b7d5d0713c7f9bcfa10e130690020bada3c1c337","modified":1541662898956},{"_id":"themes/next/layout/archive.swig","hash":"f0a8225feafd971419837cdb4bcfec98a4a59b2f","modified":1523677104000},{"_id":"themes/next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1523677104000},{"_id":"themes/next/layout/index.swig","hash":"783611349c941848a0e26ee2f1dc44dd14879bd1","modified":1523677104000},{"_id":"themes/next/layout/page.swig","hash":"969caaee05bdea725e99016eb63d810893a73e99","modified":1523677104000},{"_id":"themes/next/layout/post.swig","hash":"b3589a8e46288a10d20e41c7a5985d2493725aec","modified":1523677104000},{"_id":"themes/next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1523677104000},{"_id":"themes/next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1523677104000},{"_id":"themes/next/scripts/merge-configs.js","hash":"81e86717ecfb775986b945d17f0a4ba27532ef07","modified":1523677104000},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1523677104000},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1523677104000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1523677104000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1523677104000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1523677104000},{"_id":"source/_posts/BST/satuation2-2.png","hash":"9f15a6020f8f68d4bb8218c1aaaa03c19add5a52","modified":1542769054262},{"_id":"source/_posts/BST/一个二叉搜索树.jpg","hash":"5f1fda566201c3f3a2ddef8c29ac347fad044d42","modified":1542767120740},{"_id":"source/_posts/BST/satuation3-2.png","hash":"e9b37d41db6b80e5f18ddd8f6c89122c7e3581a9","modified":1542769088343},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1523677104000},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1523677104000},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"665a928604f99d2ba7dc4a4a9150178229568cc6","modified":1523677104000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1523677104000},{"_id":"themes/next/layout/_macro/post.swig","hash":"070d7124812e0dc172615bd4c91f7a7002d13222","modified":1541662910023},{"_id":"themes/next/layout/_macro/reward.swig","hash":"56e8d8556cf474c56ae1bef9cb7bbd26554adb07","modified":1523677104000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"6a54c3c85ff6b19d275827a327abbf4bd99b2ebf","modified":1523677104000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1523677104000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4a6f5b1792b2e5262b7fdab9a716b3108e2f09c7","modified":1523677104000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"4b3d53a432528a55d5a58083099682e7126dc123","modified":1541663408176},{"_id":"themes/next/layout/_partials/head.swig","hash":"6b94fe8f3279daea5623c49ef4bb35917ba57510","modified":1523677104000},{"_id":"themes/next/layout/_partials/header.swig","hash":"ed042be6252848058c90109236ec988e392d91d4","modified":1523677104000},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1523677104000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1523677104000},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1523677104000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1523677104000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1523677104000},{"_id":"themes/next/layout/_scripts/lean-analytics.swig","hash":"722786a8795a1d46a25b309d9d24b54cc23e4669","modified":1541494207316},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"a266f96ad06ee87bdeae6e105a4b53cd587bbd04","modified":1523677104000},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1523677104000},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1523677104000},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1523677104000},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"5fe0447cc88a5a63b530cf0426f93c4634811876","modified":1523677104000},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1523677104000},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1523677104000},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1523677104000},{"_id":"themes/next/scripts/tags/button.js","hash":"d023f10a00077f47082b0517e2ad666e6e994f60","modified":1523677104000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1523677104000},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1523677104000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1523677104000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1523677104000},{"_id":"themes/next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1523677104000},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1523677104000},{"_id":"themes/next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1523677104000},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1523677104000},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1523677104000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1523677104000},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1523677104000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1523677104000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1523677104000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1523677104000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1523677104000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1523677104000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1523677104000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1523677104000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1523677104000},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1523677104000},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1523677104000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1523677104000},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1523677104000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1523677104000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1523677104000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1523677104000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1523677104000},{"_id":"source/_posts/BST/BST测试程序执行结果.jpg","hash":"d5a3a86be2571d922920543a17b96b7b79966112","modified":1542782712021},{"_id":"source/_posts/BST/satuation1.png","hash":"6fed712ec4f2b7c9bdeda67b35e70c9a1d67cf1a","modified":1542769020354},{"_id":"source/_posts/BST/satuation2-1.png","hash":"b3dbdaa72e2a55ff8d9685411f4a759b8e1bb281","modified":1542769044458},{"_id":"source/_posts/BST/satuation3-1.png","hash":"cc12e28e7e800c0bd3663d7190697c483299392a","modified":1542769078238},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1523677104000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1523677104000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1523677104000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1523677104000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1523677104000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1523677104000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1523677104000},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1523677104000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1523677104000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1523677104000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1523677104000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1523677104000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1523677104000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1523677104000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1523677104000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1523677104000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1523677104000},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1523677104000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1523677104000},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1523677104000},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1523677104000},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1523677104000},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1523677104000},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1523677104000},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1523677104000},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"1cd01c6e92ab1913d48e556a92bb4f28b6dc4996","modified":1523677104000},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1523677104000},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1523677104000},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1523677104000},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1523677104000},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1523677104000},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1523677104000},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1523677104000},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1523677104000},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1523677104000},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"10160daceaa6f1ecf632323d422ebe2caae49ddf","modified":1523677104000},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1523677104000},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"aa0629277d751c55c6d973e7691bf84af9b17a60","modified":1523677104000},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1523677104000},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"fcabbb241f894c9a6309c44e126cf3e8fea81fd4","modified":1523677104000},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1523677104000},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1523677104000},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1523677104000},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1523677104000},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1523677104000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1523677104000},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1523677104000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"9ab65361ba0a12a986edd103e56492644c2db0b8","modified":1523677104000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1523677104000},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"99fbb4686ea9a3e03a4726ed7cf4d8f529034452","modified":1523677104000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1523677104000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"f29165e36489a87ba32d17dddfd2720d84e3f3ec","modified":1523677104000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"29c261fa6b4046322559074d75239c6b272fb8a3","modified":1523677104000},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1523677104000},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1523677104000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1523677104000},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1523677104000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1523677104000},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1523677104000},{"_id":"themes/next/source/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1523677104000},{"_id":"themes/next/source/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1523677104000},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1523677104000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1523677104000},{"_id":"themes/next/source/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1523677104000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1523677104000},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1523677104000},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1523677104000},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1523677104000},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1523677104000},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1523677104000},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1523677104000},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1523677104000},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1523677104000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1523677104000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1523677104000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1523677104000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1523677104000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1523677104000},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1523677104000},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1523677104000},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1523677104000},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1523677104000},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1523677104000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1523677104000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1523677104000},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1523677104000},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1523677104000},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1523677104000},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1523677104000},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1523677104000},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1523677104000},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1523677104000},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1523677104000},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1523677104000},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1523677104000},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1523677104000},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1523677104000},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1523677104000},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1523677104000},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1523677104000},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1523677104000},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1523677104000},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1523677104000},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1523677104000},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1523677104000},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1523677104000},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1523677104000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1523677104000},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1523677104000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1523677104000},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1523677104000},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1523677104000},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1523677104000},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1523677104000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1523677104000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1523677104000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1523677104000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1523677104000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1523677104000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1523677104000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1523677104000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"f7c44b0ee46cf2cf82a4c9455ba8d8b55299976f","modified":1523677104000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1523677104000},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1523677104000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1523677104000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1523677104000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1523677104000},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"18c3336ee3d09bd2da6a876e1336539f03d5a973","modified":1523677104000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1523677104000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1523677104000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1523677104000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1523677104000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"3b25edfa187d1bbbd0d38b50dd013cef54758abf","modified":1523677104000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1523677104000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1523677104000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1523677104000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1523677104000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"4aac01962520d60b03b23022ab601ad4bd19c08c","modified":1523677104000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1523677104000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1523677104000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1523677104000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1523677104000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1523677104000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1523677104000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1523677104000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"9d16fa3c14ed76b71229f022b63a02fd0f580958","modified":1523677104000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1523677104000},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1523677104000},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1523677104000},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1523677104000},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1523677104000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1523677104000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1523677104000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1523677104000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1523677104000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1523677104000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1523677104000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1523677104000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1523677104000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1523677104000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1523677104000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1523677104000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1523677104000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1523677104000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1523677104000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1523677104000},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1523677104000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1523677104000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1523677104000},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1523677104000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"7905a7f625702b45645d8be1268cb8af3f698c70","modified":1523677104000},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1523677104000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"25dc25f61a232f03ca72472b7852f882448ec185","modified":1523677104000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1523677104000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1523677104000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1523677104000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1523677104000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1523677104000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1523677104000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1523677104000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1523677104000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1523677104000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1523677104000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1523677104000},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1523677104000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1523677104000},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1523677104000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1523677104000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"535b3b4f8cb1eec2558e094320e7dfb01f94c0e7","modified":1523677104000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1523677104000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"aea21141015ca8c409d8b33e3e34ec505f464e93","modified":1523677104000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1523677104000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1523677104000},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1523677104000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1523677104000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"d5a4e4fc17f1f7e7c3a61b52d8e2e9677e139de7","modified":1523677104000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1523677104000},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1523677104000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"262debfd4442fa03d9919ceb88b948339df03fb0","modified":1523677104000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"0a6c0efffdf18bddbc1d1238feaed282b09cd0fe","modified":1523677104000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1523677104000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1523677104000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1523677104000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1523677104000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1523677104000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"12937cae17c96c74d5c58db6cb29de3b2dfa14a2","modified":1523677104000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1523677104000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"50305b6ad7d09d2ffa4854e39f41ec1f4fe984fd","modified":1523677104000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1523677104000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1523677104000},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1523677104000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"37e951e734a252fe8a81f452b963df2ba90bfe90","modified":1523677104000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1523677104000},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1523677104000},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1523677104000},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1523677104000},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1523677104000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1523677104000},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1523677104000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1523677104000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1523677104000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1523677104000},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1523677104000},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1523677104000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1523677104000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1523677104000},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1523677104000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1ccfbd4d0f5754b2dc2719a91245c95f547a7652","modified":1523677104000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1523677104000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1523677104000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1523677104000},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1523677104000},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1523677104000},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1523677104000},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1523677104000},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1523677104000},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1523677104000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1523677104000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1523677104000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1523677104000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1523677104000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1523677104000},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1523677104000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1523677104000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1523677104000},{"_id":"source/images/avatar.jpg","hash":"edd17fbde74c15ca31737137f340b5477fe3c50c","modified":1541042270489},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1523677104000},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1523677104000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1523677104000},{"_id":"public/about/index.html","hash":"a559a1624db05f11b0d02f9844640d7c9dd47697","modified":1564411898110},{"_id":"public/categories/index.html","hash":"c52ec0587d56b33866a4657737abac5ae85fdd05","modified":1564411898110},{"_id":"public/tags/index.html","hash":"f8fa32eff12526e2605d1e67f06cea389441f2fb","modified":1564411898110},{"_id":"public/archives/2018/10/index.html","hash":"fc2a49e45bd11d37340d3d1afe45ab5807d1606b","modified":1564411898110},{"_id":"public/archives/2018/11/index.html","hash":"d1261f32177f557cd6cbcf7bfe1ef839392ee510","modified":1564411898110},{"_id":"public/archives/2018/12/index.html","hash":"37cd8a5596ad316e80f0b09b30a6048dfb172ff6","modified":1564411898110},{"_id":"public/archives/2019/index.html","hash":"b4342ce25df9e25c29ee339ffe534e31830fe25b","modified":1564411898110},{"_id":"public/archives/2019/03/index.html","hash":"79212b753e9d234aaa9189bc96166b30542a5dd6","modified":1564411898110},{"_id":"public/archives/2019/07/index.html","hash":"e606e3d56b91a3e339f0ba5d1db375ca41e48645","modified":1564411898110},{"_id":"public/categories/数据结构/index.html","hash":"16f44f34f1f176c3230157f430b36cad0cb5bd83","modified":1564411898110},{"_id":"public/categories/算法/index.html","hash":"0b03d728607066af995b954e6d32b21744138d96","modified":1564411898110},{"_id":"public/categories/杂/index.html","hash":"8ccf62d64d13d78af0871ad25103e703b18145a5","modified":1564411898110},{"_id":"public/categories/工作/index.html","hash":"5464bf00906fb719ba80146e97bd14e6fa0055a6","modified":1564411898111},{"_id":"public/categories/Data-Structure/index.html","hash":"7feed38bc29d808b80346cb11eac9bd307787421","modified":1564411898111},{"_id":"public/categories/心路历程/index.html","hash":"f38b041f2085739bd1cc569d67415543897e953e","modified":1564411898111},{"_id":"public/tags/数据结构/index.html","hash":"0778ca89faaa58d2e6436a145900b02fd00e0cab","modified":1564411898111},{"_id":"public/tags/BST/index.html","hash":"c143161654392a40566e82ee44ba794b2976976a","modified":1564411898111},{"_id":"public/tags/二叉搜索树/index.html","hash":"e2e8320465e4f2a1129b74ebc2866b4d268af32a","modified":1564411898111},{"_id":"public/tags/有环单链表/index.html","hash":"3a2c55b4d565ae0f5682e9a3a3c9bc2f94151d9c","modified":1564411898111},{"_id":"public/tags/算法/index.html","hash":"2a9cab567a3dba95cdba039dcd5f24c6aba01eda","modified":1564411898111},{"_id":"public/tags/动态规划/index.html","hash":"79a46eb0287e409b2231be84f8e8b47226db155f","modified":1564411898111},{"_id":"public/tags/最长公共子序列/index.html","hash":"43fbb05dc7304267b7fe79022e9ec2779b8a5baf","modified":1564411898111},{"_id":"public/tags/诗歌-感悟-人生/index.html","hash":"83c59dacf419328be23120ec222e9d59950d663b","modified":1564411898111},{"_id":"public/tags/动态内存-栈-堆/index.html","hash":"8c3dfb24bd78722217f32a84277c75a4b3657db7","modified":1564411898111},{"_id":"public/tags/单链表/index.html","hash":"1c48f2be44a52044dee7a9f380ea3aa57753ad01","modified":1564411898111},{"_id":"public/tags/杂谈/index.html","hash":"2a688c218b2a832f0aad2ca358488da3a114e46c","modified":1564411898111},{"_id":"public/2019/07/29/poet1-我会采更多的雏菊/index.html","hash":"923f5f68a5c3d7b8ac70ccd07e6d750991a39940","modified":1564411898111},{"_id":"public/2019/07/29/pthreadThoughts/index.html","hash":"2de2c544bab14adca4a914a16a80f327a4c40f0c","modified":1564411898111},{"_id":"public/2019/03/15/rethinkOfMelloc/index.html","hash":"9b67ce14f810c1bfa120e8c2fd4ee7887bb9b02b","modified":1564411898111},{"_id":"public/2018/12/04/LSC-DP/index.html","hash":"4e9bf480cc7d382c940a40310864983cf71e44bf","modified":1564411898111},{"_id":"public/2018/11/19/BST/index.html","hash":"1f56475a04539a70538a8a4e4b517b5206d03930","modified":1564411898112},{"_id":"public/2018/11/08/CycleList/index.html","hash":"33f762283e4b0d27cb9660da5e392f59c7bb219e","modified":1564411898112},{"_id":"public/2018/10/31/single-linklist/index.html","hash":"974ff03747882b0814775169d5b089cb87640e02","modified":1564411898112},{"_id":"public/2018/10/29/start-from-now/index.html","hash":"c79011fbe258ff2be00b5fc396066042d635cbcc","modified":1564411898112},{"_id":"public/archives/index.html","hash":"2b6b755cfd69a731d58d6edc5c1eca7e7eaed122","modified":1564411898112},{"_id":"public/archives/2018/index.html","hash":"38fd27719751f740250dda715b8603ddb58d0991","modified":1564411898112},{"_id":"public/index.html","hash":"c59288b899f2183d46799509f76a4b25487e1867","modified":1564411898112},{"_id":"public/CNAME","hash":"70bbc165e2970472777e6fc52848822b725d53ab","modified":1564411898118},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1564411898119},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1564411898119},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1564411898119},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1564411898119},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1564411898119},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1564411898119},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1564411898119},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1564411898119},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1564411898119},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1564411898119},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1564411898119},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1564411898119},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1564411898119},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1564411898119},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1564411898119},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1564411898119},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1564411898119},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1564411898119},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1564411898119},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1564411898119},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1564411898119},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1564411898119},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1564411898120},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1564411898120},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1564411898120},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1564411898120},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1564411898120},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1564411898120},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1564411898120},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1564411898120},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1564411898120},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1564411898120},{"_id":"public/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1564411898120},{"_id":"public/2018/11/19/BST/satuation2-2.png","hash":"9f15a6020f8f68d4bb8218c1aaaa03c19add5a52","modified":1564411898120},{"_id":"public/2018/11/19/BST/一个二叉搜索树.jpg","hash":"5f1fda566201c3f3a2ddef8c29ac347fad044d42","modified":1564411898120},{"_id":"public/2018/11/19/BST/satuation3-2.png","hash":"e9b37d41db6b80e5f18ddd8f6c89122c7e3581a9","modified":1564411898120},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1564411898469},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1564411898476},{"_id":"public/2018/11/19/BST/BST测试程序执行结果.jpg","hash":"d5a3a86be2571d922920543a17b96b7b79966112","modified":1564411898479},{"_id":"public/2018/11/19/BST/satuation1.png","hash":"6fed712ec4f2b7c9bdeda67b35e70c9a1d67cf1a","modified":1564411898479},{"_id":"public/2018/11/19/BST/satuation2-1.png","hash":"b3dbdaa72e2a55ff8d9685411f4a759b8e1bb281","modified":1564411898479},{"_id":"public/2018/11/19/BST/satuation3-1.png","hash":"cc12e28e7e800c0bd3663d7190697c483299392a","modified":1564411898480},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1564411898486},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1564411898486},{"_id":"public/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1564411898486},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1564411898486},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1564411898486},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1564411898486},{"_id":"public/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1564411898487},{"_id":"public/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1564411898487},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1564411898487},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1564411898487},{"_id":"public/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1564411898487},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1564411898487},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1564411898487},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1564411898487},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1564411898487},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1564411898487},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1564411898487},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1564411898487},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1564411898487},{"_id":"public/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1564411898487},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1564411898488},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1564411898488},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1564411898488},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1564411898488},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1564411898488},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1564411898488},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1564411898488},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1564411898488},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1564411898488},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1564411898488},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1564411898488},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1564411898488},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1564411898488},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1564411898488},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1564411898488},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1564411898488},{"_id":"public/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1564411898488},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1564411898488},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1564411898489},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1564411898489},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1564411898489},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1564411898489},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1564411898489},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1564411898489},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1564411898489},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1564411898489},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1564411898489},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1564411898489},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1564411898489},{"_id":"public/css/main.css","hash":"028a3c0bab4ae083910173a7c5e58a900e3daca0","modified":1564411898489},{"_id":"public/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1564411898489},{"_id":"public/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1564411898489},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1564411898489},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1564411898490},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1564411898490},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1564411898490},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1564411898490},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1564411898490},{"_id":"public/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1564411898490},{"_id":"public/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1564411898490},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1564411898490},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1564411898490},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1564411898490},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1564411898490},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1564411898490},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1564411898490},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1564411898490},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1564411898490},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1564411898490},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1564411898490},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1564411898491},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1564411898491},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1564411898491},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1564411898500},{"_id":"public/images/avatar.jpg","hash":"edd17fbde74c15ca31737137f340b5477fe3c50c","modified":1564411898548}],"Category":[{"name":"数据结构","_id":"cjyoig8iu0002pq0jmon191or"},{"name":"算法","_id":"cjyoig8iy0007pq0jauebuvh5"},{"name":"杂","_id":"cjyoig8j4000fpq0jgkxfrxfy"},{"name":"工作","_id":"cjyoig8j4000lpq0jn16dbjll"},{"name":"Data Structure","_id":"cjyoig8j5000ppq0j24rifxzl"},{"name":"心路历程","_id":"cjyoig8j6000spq0j1s45w11b"}],"Data":[],"Page":[{"title":"about","date":"2018-11-02T02:27:28.000Z","type":"about","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2018-11-02 10:27:28\ntype: about\n---\n","updated":"2018-11-02T02:27:49.088Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjyoig8mt001fpq0jpw63rs9a","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"catagories","date":"2018-11-02T02:07:05.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: catagories\ndate: 2018-11-02 10:07:05\ntype: categories\n---\n","updated":"2018-11-02T02:11:39.034Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cjyoig8mv001gpq0j8d1m48in","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2018-11-02T02:23:09.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2018-11-02 10:23:09\ntype: tags\n---\n","updated":"2018-11-02T02:23:49.101Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjyoig8mx001hpq0j7szslkds","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"二叉搜索树初探（BST）","date":"2018-11-19T11:22:44.000Z","_content":"\n# 前言\n今天来说说经典数据结构之一，二叉搜索树（BST）。\n在学习过链表后，再来看二叉树的实现会轻松不少，因为都包含了很多指针操作，同为通过指针指向连接起来的数据结构。建议先把链表吃透，再来看树的实现。\n\n# 什么是二叉搜索树\n二叉搜索树（Binary Search Tree），简称BST，也称为二叉搜索树、有序二叉树或排序二叉树，是指一棵**空树**或者具有下列性质的二叉树：\n<!-- more -->\n\n> 1、若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；\n> 2、若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；\n> 3、任意节点的左、右子树也分别为二叉查找树；\n> 4、没有键值相等的节点。\n\n下图是否是一颗二叉搜索树呢？\n<img src=\"https://blog-pics.nos-eastchina1.126.net/%E4%B8%80%E4%B8%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.jpg\" width=\"40%\" height=\"50%\">\n    答案是否，因为左子树的最大节点4比根节点3要大，不符合性质1，这个在接下来的`如何判断是否为BST`中还会讨论到。\n    二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低。平均查找复杂度为 O(log n)，查找的效率和树的高度成正比，在最坏情况下为O(n)，这时二叉树退化成一条线。\n    下面就和我开始一起构建一颗二叉搜索树吧！\n  \n# 二叉搜索树的方法们\nBST的方法包括创建、查找、插入、删除和左旋右旋等，今天主要说说前几项。\n\n## BST节点的结构\n\n``` C\nclass binaryTreeNode \n{\npublic:\n\tint item;  // 节点内容\n\tbinaryTreeNode *l_child, *r_child;  // 左孩子和右孩子的指针\n\tbinaryTreeNode(int item):item(item),l_child(NULL),r_child(NULL) { }\n};\n```\n\n这里为了方便讲解，暂定二叉树的节点元素为int类型，实际开发中一般会换成特定的结构体。\n\n## 定义一个BST类\n\n为了方便以后添加树的新方法，定义一个名为binaryTree的类，如下：\n\n``` C\n#include <iostream>\n#include <set>\n#include <vector>\nusing namespace std;\nclass binaryTree \n{\nprivate:\n\tset<int> elemSet;  // 存放树中已有元素\n\tbool ifExistsElement(int elem);  // 是否存在一个元素\npublic:\n\tbinaryTree() { }\n\tvoid createBST(binaryTreeNode * &root, vector<int> &v);  // 创建一个BST\n\tvoid inorder(binaryTreeNode *root);  // 中序遍历\n\tbinaryTreeNode *insert(binaryTreeNode *root, int item);  // 插入\n\tbinaryTreeNode *searchNode(binaryTreeNode *root, int value);  // 查找节点\n\tbinaryTreeNode *leftRotation(binaryTreeNode *root, binaryTreeNode *node);  // 左旋\n\tbinaryTreeNode *rightRotation(binaryTreeNode *root, binaryTreeNode *node);  // 右旋\n\tbinaryTreeNode *maxValueNode(binaryTreeNode *root);  // 找到最小节点\n\tbinaryTreeNode *minValueNode(binaryTreeNode *root);  // 找到最大节点\n\tbinaryTreeNode *deleteNode(binaryTreeNode *root, int delete_item);   // 删除节点\n};\n```\n\n## 插入节点\n\n插入操作分两步：\n1. 找到要插入父节点的位置；\n2. 比较与该结点的大小，并插入。\n\n如何找到要插入的父节点位置，这里我们可以使用递归较为方便；在做插入操作时需要注意的是，当树为**空**时，需要申请一个新节点，并将其作为结果返回。*为什么不直接改变根节点的指向，让它直接指向新节点呢？*那样就需要用到二级指针，复杂化原有的逻辑；这样做能保持方法实现的一致性，只不过在一棵树为空树时，插入节点后要获取其返回值才行；同时还需考虑节点是否重复。\n\t⁃\t**代码如下：**\n\n``` C\n/* 插入一个节点  */\nbinaryTreeNode *binaryTree::insert(binaryTreeNode *root, int item)\n{\n\t// 检查是否元素重复\n\tif (ifExistsElement(item))\n\t{\n\t\tprintf(\"element %d exists\\n\", item);\n\t\treturn root;\n\t}\n\t\n\tif (root == NULL)  // （核心代码）\n\t{\n\t\tbinaryTreeNode *temp = new binaryTreeNode(item);\n\t\tthis->elemSet.insert(item);  // 插入已有元素集合\n\t\treturn temp;\n\t}\n\n\tif (item > root->item)\n\t\troot->r_child = insert(root->r_child, item);\n\telse\n\t\troot->l_child = insert(root->l_child, item);\n\n\treturn root;\n}\n```\n\n通过以上代码我们可以看到，其实插入操作的***真正核心***就在第一个`if (root == NULL)`中。不管树的状态如何，程序最后都会走到这一步，然后再逐步返回。这也正是递归程序的真正意义，最后的结果永远会回到最终的地方，那里才是核心代码，其他都是为了走到那里的流程。\n\n## BST的创建\n\n有了插入操作，创建BST就很简单了，我们可以把想放到树中的元素先放在一个vector里，然后逐个调用insert方法来构建BST.\n**代码如下：**\n\n``` C\n/* 创建一颗二叉树 */\nvoid binaryTree::createBST(binaryTreeNode* &root, vector<int> &v)\n{\n\tif (v.empty())\n\t\troot = NULL;\n\telse\n\t{\n\t\tfor (int val : v)  // 这里用到C++11的新标准，在编译时要注意\n\t\t\troot = insert(root, val);\n\t}\n}\n```\n\n## 删除节点\n\n删除节点稍显复杂，需要分情况讨论：\n1. 待删除节点没有孩子\n2. 待删除节点有一个孩子\n3. 待删除节点有两个孩子\n\n对于前两种情况很简单，分别用NIL和该孩子节点替换删除节点，再删除待删除节点即可；\n\n* 情况一\n![satuation1](https://blog-pics.nos-eastchina1.126.net/satuation1.png)\n* 情况二\n\n    * 变化前\n<img src=\"https://blog-pics.nos-eastchina1.126.net/satuation2-1.png\" width=\"50%\" height=\"50%\">\n\n    * 变化后\n<img src=\"https://blog-pics.nos-eastchina1.126.net/satuation2-2.png\" width=\"50%\" height=\"50%\">\n\n\n如果删除节点有两个孩子，这种情况可以找到删除节点的*_左孩子中最大节点_*、或*_右孩子中最小节点_*替换待删除节点，再释放删除节点。如下图，要删除12：\n\n* 情况三\n    * 变化前\n<img src=\"https://blog-pics.nos-eastchina1.126.net/satuation3-1.png\" width=\"50%\" height=\"50%\">\n    \n    * 变化后\n<img src=\"https://blog-pics.nos-eastchina1.126.net/satuation3-2.png\" width=\"50%\" height=\"50%\">\n\n为什么可以这样做呢？正常的思路考虑就是：用左子树中最大节点替换根节点，由于它比所有左子树其他节点要大，而且比右子树中所有节点要小，故用其替换当前根节点不会使BST的性质发生变化；用右子树中最小节点也是同理。\n和这个类似的操作还有二叉树的**左旋**的**右旋**，都利用了一个BST可以有多种**呈现方式**的特性。\n**实现代码如下：**\n\n``` C\nbinaryTreeNode *binaryTree::deleteNode(binaryTreeNode *root, int value)\n{\n\tif (root == NULL)  return NULL;\n\n\tif (value > root->item)\n\t\troot->r_child = deleteNode(root->r_child, value);\n\telse if (value < root->item)\n\t\troot->l_child = deleteNode(root->l_child, value);\n\telse\n\t{\n\t\t// 删除节点有一个孩子节点或无孩子节点（核心代码，最终调用的地方，然后再回调）\n\t\tif (root->l_child == NULL)\n\t\t{\n\t\t\tbinaryTreeNode *temp = root->r_child;\n\t\t\tdelete(root);\n\t\t\treturn temp;\n\t\t}\n\t\telse if (root->r_child == NULL)\n\t\t{\n\t\t\tbinaryTreeNode *temp = root->l_child;\n\t\t\tdelete(root);\n\t\t\treturn temp;\n\t\t}\n\t\t// 删除节点有两个孩子节点\n\t\telse\n\t\t{\n\t\t\tbinaryTreeNode *leftChildMaxNode = maxValueNode(root->l_child);\n\t\t\troot->item = leftChildMaxNode->item;\n\t\t\troot->l_child = deleteNode(root->l_child, leftChildMaxNode->item);\n\t\t}\n\t}\n\treturn root;\n}\n```\n\n上面代码当删除节点有两个孩子时，首先用了左子树中最大节点替换了删除节点的内容，然后递归删除了左子树的最大节点，达到替换的目的。\n\n## 其他一些功能方法\n* 找到BST的最大节点\n-- 找一颗BST的最大节点就是找到其**最深的右孩子节点**，找到最小节点也是同理，即找到其**最深的左孩子节点**，便不再赘述。\n\n**代码如下：**\n\n``` C\nbinaryTreeNode *binaryTree::maxValueNode(binaryTreeNode *root)\n{\n\tbinaryTreeNode *cur = root;\n\twhile (cur->r_child)\n\t\tcur = cur->r_child;\n\treturn cur;\n}\n```\n\n* 判断一个元素是否已存在\n\n``` C\n/* 利用set的无重复元素的性质，判断一个元素是否在树中  */\nbool binaryTree::ifExistsElement(int elem)\n{\n\tfor (auto pd = this->elemSet.begin(); pd != this->elemSet.end(); ++pd)\n\t{\n\t\tif (*pd == elem) \n\t\t\treturn true;\n\t}\n\treturn false;\n}\n```\n\n* 中序遍历\n-- 用递归的方法对一颗BST中序遍历（中根序遍历），中序遍历的结果是**从小到大排好序**的。\n\n``` C\n/* 中序遍历 */\nvoid binaryTree::inorder(binaryTreeNode *root)\n{\n\tif (root != NULL)\n\t{\n\t\tinorder(root->l_child);\n\t\tprintf(\"%d \\t\", root->item);\n\t\tinorder(root->r_child);\n\t}\n\telse return;  // 可以不写，写了方便理解递归\n}\n```\n\n* 判断一棵树是否为二叉搜索树的方法（非类方法）\n-- 要判断一颗二叉树树是不是BST，即要判断是否它的所有节点都满足：\n    * 左孩子中最大的节点小于当前节点；\n    * 右孩子中最小的节点大于当前节点；\n    \n**代码如下：**\n\n``` C\n/* 判断一棵树是否为二叉搜索树（BST）*/\nbool ifIsA_BST(binaryTreeNode *root)\n{\n\tbinaryTree *tree = new binaryTree();\n\tif (root == NULL)\n\t\treturn true;\n\tif (root->l_child != NULL && tree->maxValueNode(root->l_child)->item > root->item)\n\t\treturn false;\n\tif (root->r_child != NULL && tree->minValueNode(root->r_child)->item < root->item)\n\t\treturn false;\n\tif (!ifIsA_BST(root->l_child) || !ifIsA_BST(root->r_child))  // 递归做判断\n\t\treturn false;\n\treturn true;\n}\n\n```\n这种方法不是最高效的，但比较容易理解，如果想了解更高效的方法，请参阅[判断是否是BST的方法](https://www.geeksforgeeks.org/a-program-to-check-if-a-binary-tree-is-bst-or-not/)\n* 寻找一个节点\n\n``` C\n/* 寻找一个节点，返回该节点的指针，没找到返回NULL */\nbinaryTreeNode *binaryTree::searchNode(binaryTreeNode *root, int value)\n{\n\tif (root != NULL)\n\t{\n\t\tif (value == root->item)\n\t\t\treturn root;\n\t\telse if (value > root->item)\n\t\t\treturn searchNode(root->r_child, value);\n\t\telse if (value < root->item)\n\t\t\treturn searchNode(root->l_child, value);\n\t}\n\telse return NULL;\n}\n```\n\n## 测试程序\nBST实现好了，下面来写代码测试它：\n\n``` C\nint main()\n{\n\t/* Let us create following BST \n     *         50 \n     *      /     \\ \n     *     30      70 \n     *    /  \\    /  \\ \n     *  20   40  60   80 */\n\tbinaryTreeNode *root = NULL;\n\tbinaryTree *tree = new binaryTree();\n\troot = tree->insert(root, 50);\n\ttree->insert(root, 30);\n\ttree->insert(root, 20);\n\ttree->insert(root, 40);\n\ttree->insert(root, 70);\n\ttree->insert(root, 60);\n\ttree->insert(root, 80);\n\ttree->insert(root, 80);\n\tcout << \"Inorder traverse tree1\" << endl;\n\ttree->inorder(root);\n\n\tcout << endl << \"max is \" << tree->maxValueNode(root)->item << endl;\n\n\tcout << \"delete 80\" << endl;\n\ttree->deleteNode(root, 80);\n\tcout << \"after delete\" << endl;\n\ttree->inorder(root);\n\n\tcout << endl << \"delete 30\" << endl;\n\ttree->deleteNode(root, 30);\n\tcout << \"after delete\" << endl;\n\ttree->inorder(root);\n\n\tcout << endl << \"second tree(create method)\" << endl;\n\tbinaryTreeNode *root1;\n\tvector<int> v{1,2,3,4,5,8,7};\n\ttree->createBST(root1, v);\n\tcout << \"Inorder traverse tree2\" << endl;\n\ttree->inorder(root1);\n\n\tif (ifIsA_BST(root1))\n\t\tcout << endl << \"It's a BST.\" << endl;\n\telse\n\t\tcout << endl << \"It's not a BST.\" << endl;\n\n\treturn 0;\n}\n```\n\n执行结果：\n<img src=\"https://blog-pics.nos-eastchina1.126.net/BST%E6%B5%8B%E8%AF%95%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C.jpg\" width=\"60%\" height=\"50%\">\n\n# 总结\n以上对二叉搜索树（BST）的结构，性质，基本方法包括：创建、插入、删除、查找等，以及其他一些功能函数做了较为详细的分析，相信大家对BST已经有了更多的认识。\n在学习BST的时候，递归是避免不了要理解的东西，想要理解递归，就要找到递归中最核心的代码部分，其余都是为了走向那里所做的流程处理，只不过是自己调用了自己，然后再从核心返回，一层一层调用回去。\n\n# 参考链接\n[BST的基本操作](https://www.geeksforgeeks.org/binary-search-tree-set-2-delete/)\n[判断是否是BST的方法](https://www.geeksforgeeks.org/a-program-to-check-if-a-binary-tree-is-bst-or-not/)\n[一个很好的学习数据结构和算法的网站(左右旋转）](http://www.algolist.net/Data_structures/Binary_search_tree/Removal)\n\n\n","source":"_posts/BST.md","raw":"---\ntitle: 二叉搜索树初探（BST）\ndate: 2018-11-19 19:22:44\ntags: \n- 数据结构\n- BST \n- 二叉搜索树\ncategories: \n- 数据结构\n---\n\n# 前言\n今天来说说经典数据结构之一，二叉搜索树（BST）。\n在学习过链表后，再来看二叉树的实现会轻松不少，因为都包含了很多指针操作，同为通过指针指向连接起来的数据结构。建议先把链表吃透，再来看树的实现。\n\n# 什么是二叉搜索树\n二叉搜索树（Binary Search Tree），简称BST，也称为二叉搜索树、有序二叉树或排序二叉树，是指一棵**空树**或者具有下列性质的二叉树：\n<!-- more -->\n\n> 1、若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；\n> 2、若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；\n> 3、任意节点的左、右子树也分别为二叉查找树；\n> 4、没有键值相等的节点。\n\n下图是否是一颗二叉搜索树呢？\n<img src=\"https://blog-pics.nos-eastchina1.126.net/%E4%B8%80%E4%B8%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.jpg\" width=\"40%\" height=\"50%\">\n    答案是否，因为左子树的最大节点4比根节点3要大，不符合性质1，这个在接下来的`如何判断是否为BST`中还会讨论到。\n    二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低。平均查找复杂度为 O(log n)，查找的效率和树的高度成正比，在最坏情况下为O(n)，这时二叉树退化成一条线。\n    下面就和我开始一起构建一颗二叉搜索树吧！\n  \n# 二叉搜索树的方法们\nBST的方法包括创建、查找、插入、删除和左旋右旋等，今天主要说说前几项。\n\n## BST节点的结构\n\n``` C\nclass binaryTreeNode \n{\npublic:\n\tint item;  // 节点内容\n\tbinaryTreeNode *l_child, *r_child;  // 左孩子和右孩子的指针\n\tbinaryTreeNode(int item):item(item),l_child(NULL),r_child(NULL) { }\n};\n```\n\n这里为了方便讲解，暂定二叉树的节点元素为int类型，实际开发中一般会换成特定的结构体。\n\n## 定义一个BST类\n\n为了方便以后添加树的新方法，定义一个名为binaryTree的类，如下：\n\n``` C\n#include <iostream>\n#include <set>\n#include <vector>\nusing namespace std;\nclass binaryTree \n{\nprivate:\n\tset<int> elemSet;  // 存放树中已有元素\n\tbool ifExistsElement(int elem);  // 是否存在一个元素\npublic:\n\tbinaryTree() { }\n\tvoid createBST(binaryTreeNode * &root, vector<int> &v);  // 创建一个BST\n\tvoid inorder(binaryTreeNode *root);  // 中序遍历\n\tbinaryTreeNode *insert(binaryTreeNode *root, int item);  // 插入\n\tbinaryTreeNode *searchNode(binaryTreeNode *root, int value);  // 查找节点\n\tbinaryTreeNode *leftRotation(binaryTreeNode *root, binaryTreeNode *node);  // 左旋\n\tbinaryTreeNode *rightRotation(binaryTreeNode *root, binaryTreeNode *node);  // 右旋\n\tbinaryTreeNode *maxValueNode(binaryTreeNode *root);  // 找到最小节点\n\tbinaryTreeNode *minValueNode(binaryTreeNode *root);  // 找到最大节点\n\tbinaryTreeNode *deleteNode(binaryTreeNode *root, int delete_item);   // 删除节点\n};\n```\n\n## 插入节点\n\n插入操作分两步：\n1. 找到要插入父节点的位置；\n2. 比较与该结点的大小，并插入。\n\n如何找到要插入的父节点位置，这里我们可以使用递归较为方便；在做插入操作时需要注意的是，当树为**空**时，需要申请一个新节点，并将其作为结果返回。*为什么不直接改变根节点的指向，让它直接指向新节点呢？*那样就需要用到二级指针，复杂化原有的逻辑；这样做能保持方法实现的一致性，只不过在一棵树为空树时，插入节点后要获取其返回值才行；同时还需考虑节点是否重复。\n\t⁃\t**代码如下：**\n\n``` C\n/* 插入一个节点  */\nbinaryTreeNode *binaryTree::insert(binaryTreeNode *root, int item)\n{\n\t// 检查是否元素重复\n\tif (ifExistsElement(item))\n\t{\n\t\tprintf(\"element %d exists\\n\", item);\n\t\treturn root;\n\t}\n\t\n\tif (root == NULL)  // （核心代码）\n\t{\n\t\tbinaryTreeNode *temp = new binaryTreeNode(item);\n\t\tthis->elemSet.insert(item);  // 插入已有元素集合\n\t\treturn temp;\n\t}\n\n\tif (item > root->item)\n\t\troot->r_child = insert(root->r_child, item);\n\telse\n\t\troot->l_child = insert(root->l_child, item);\n\n\treturn root;\n}\n```\n\n通过以上代码我们可以看到，其实插入操作的***真正核心***就在第一个`if (root == NULL)`中。不管树的状态如何，程序最后都会走到这一步，然后再逐步返回。这也正是递归程序的真正意义，最后的结果永远会回到最终的地方，那里才是核心代码，其他都是为了走到那里的流程。\n\n## BST的创建\n\n有了插入操作，创建BST就很简单了，我们可以把想放到树中的元素先放在一个vector里，然后逐个调用insert方法来构建BST.\n**代码如下：**\n\n``` C\n/* 创建一颗二叉树 */\nvoid binaryTree::createBST(binaryTreeNode* &root, vector<int> &v)\n{\n\tif (v.empty())\n\t\troot = NULL;\n\telse\n\t{\n\t\tfor (int val : v)  // 这里用到C++11的新标准，在编译时要注意\n\t\t\troot = insert(root, val);\n\t}\n}\n```\n\n## 删除节点\n\n删除节点稍显复杂，需要分情况讨论：\n1. 待删除节点没有孩子\n2. 待删除节点有一个孩子\n3. 待删除节点有两个孩子\n\n对于前两种情况很简单，分别用NIL和该孩子节点替换删除节点，再删除待删除节点即可；\n\n* 情况一\n![satuation1](https://blog-pics.nos-eastchina1.126.net/satuation1.png)\n* 情况二\n\n    * 变化前\n<img src=\"https://blog-pics.nos-eastchina1.126.net/satuation2-1.png\" width=\"50%\" height=\"50%\">\n\n    * 变化后\n<img src=\"https://blog-pics.nos-eastchina1.126.net/satuation2-2.png\" width=\"50%\" height=\"50%\">\n\n\n如果删除节点有两个孩子，这种情况可以找到删除节点的*_左孩子中最大节点_*、或*_右孩子中最小节点_*替换待删除节点，再释放删除节点。如下图，要删除12：\n\n* 情况三\n    * 变化前\n<img src=\"https://blog-pics.nos-eastchina1.126.net/satuation3-1.png\" width=\"50%\" height=\"50%\">\n    \n    * 变化后\n<img src=\"https://blog-pics.nos-eastchina1.126.net/satuation3-2.png\" width=\"50%\" height=\"50%\">\n\n为什么可以这样做呢？正常的思路考虑就是：用左子树中最大节点替换根节点，由于它比所有左子树其他节点要大，而且比右子树中所有节点要小，故用其替换当前根节点不会使BST的性质发生变化；用右子树中最小节点也是同理。\n和这个类似的操作还有二叉树的**左旋**的**右旋**，都利用了一个BST可以有多种**呈现方式**的特性。\n**实现代码如下：**\n\n``` C\nbinaryTreeNode *binaryTree::deleteNode(binaryTreeNode *root, int value)\n{\n\tif (root == NULL)  return NULL;\n\n\tif (value > root->item)\n\t\troot->r_child = deleteNode(root->r_child, value);\n\telse if (value < root->item)\n\t\troot->l_child = deleteNode(root->l_child, value);\n\telse\n\t{\n\t\t// 删除节点有一个孩子节点或无孩子节点（核心代码，最终调用的地方，然后再回调）\n\t\tif (root->l_child == NULL)\n\t\t{\n\t\t\tbinaryTreeNode *temp = root->r_child;\n\t\t\tdelete(root);\n\t\t\treturn temp;\n\t\t}\n\t\telse if (root->r_child == NULL)\n\t\t{\n\t\t\tbinaryTreeNode *temp = root->l_child;\n\t\t\tdelete(root);\n\t\t\treturn temp;\n\t\t}\n\t\t// 删除节点有两个孩子节点\n\t\telse\n\t\t{\n\t\t\tbinaryTreeNode *leftChildMaxNode = maxValueNode(root->l_child);\n\t\t\troot->item = leftChildMaxNode->item;\n\t\t\troot->l_child = deleteNode(root->l_child, leftChildMaxNode->item);\n\t\t}\n\t}\n\treturn root;\n}\n```\n\n上面代码当删除节点有两个孩子时，首先用了左子树中最大节点替换了删除节点的内容，然后递归删除了左子树的最大节点，达到替换的目的。\n\n## 其他一些功能方法\n* 找到BST的最大节点\n-- 找一颗BST的最大节点就是找到其**最深的右孩子节点**，找到最小节点也是同理，即找到其**最深的左孩子节点**，便不再赘述。\n\n**代码如下：**\n\n``` C\nbinaryTreeNode *binaryTree::maxValueNode(binaryTreeNode *root)\n{\n\tbinaryTreeNode *cur = root;\n\twhile (cur->r_child)\n\t\tcur = cur->r_child;\n\treturn cur;\n}\n```\n\n* 判断一个元素是否已存在\n\n``` C\n/* 利用set的无重复元素的性质，判断一个元素是否在树中  */\nbool binaryTree::ifExistsElement(int elem)\n{\n\tfor (auto pd = this->elemSet.begin(); pd != this->elemSet.end(); ++pd)\n\t{\n\t\tif (*pd == elem) \n\t\t\treturn true;\n\t}\n\treturn false;\n}\n```\n\n* 中序遍历\n-- 用递归的方法对一颗BST中序遍历（中根序遍历），中序遍历的结果是**从小到大排好序**的。\n\n``` C\n/* 中序遍历 */\nvoid binaryTree::inorder(binaryTreeNode *root)\n{\n\tif (root != NULL)\n\t{\n\t\tinorder(root->l_child);\n\t\tprintf(\"%d \\t\", root->item);\n\t\tinorder(root->r_child);\n\t}\n\telse return;  // 可以不写，写了方便理解递归\n}\n```\n\n* 判断一棵树是否为二叉搜索树的方法（非类方法）\n-- 要判断一颗二叉树树是不是BST，即要判断是否它的所有节点都满足：\n    * 左孩子中最大的节点小于当前节点；\n    * 右孩子中最小的节点大于当前节点；\n    \n**代码如下：**\n\n``` C\n/* 判断一棵树是否为二叉搜索树（BST）*/\nbool ifIsA_BST(binaryTreeNode *root)\n{\n\tbinaryTree *tree = new binaryTree();\n\tif (root == NULL)\n\t\treturn true;\n\tif (root->l_child != NULL && tree->maxValueNode(root->l_child)->item > root->item)\n\t\treturn false;\n\tif (root->r_child != NULL && tree->minValueNode(root->r_child)->item < root->item)\n\t\treturn false;\n\tif (!ifIsA_BST(root->l_child) || !ifIsA_BST(root->r_child))  // 递归做判断\n\t\treturn false;\n\treturn true;\n}\n\n```\n这种方法不是最高效的，但比较容易理解，如果想了解更高效的方法，请参阅[判断是否是BST的方法](https://www.geeksforgeeks.org/a-program-to-check-if-a-binary-tree-is-bst-or-not/)\n* 寻找一个节点\n\n``` C\n/* 寻找一个节点，返回该节点的指针，没找到返回NULL */\nbinaryTreeNode *binaryTree::searchNode(binaryTreeNode *root, int value)\n{\n\tif (root != NULL)\n\t{\n\t\tif (value == root->item)\n\t\t\treturn root;\n\t\telse if (value > root->item)\n\t\t\treturn searchNode(root->r_child, value);\n\t\telse if (value < root->item)\n\t\t\treturn searchNode(root->l_child, value);\n\t}\n\telse return NULL;\n}\n```\n\n## 测试程序\nBST实现好了，下面来写代码测试它：\n\n``` C\nint main()\n{\n\t/* Let us create following BST \n     *         50 \n     *      /     \\ \n     *     30      70 \n     *    /  \\    /  \\ \n     *  20   40  60   80 */\n\tbinaryTreeNode *root = NULL;\n\tbinaryTree *tree = new binaryTree();\n\troot = tree->insert(root, 50);\n\ttree->insert(root, 30);\n\ttree->insert(root, 20);\n\ttree->insert(root, 40);\n\ttree->insert(root, 70);\n\ttree->insert(root, 60);\n\ttree->insert(root, 80);\n\ttree->insert(root, 80);\n\tcout << \"Inorder traverse tree1\" << endl;\n\ttree->inorder(root);\n\n\tcout << endl << \"max is \" << tree->maxValueNode(root)->item << endl;\n\n\tcout << \"delete 80\" << endl;\n\ttree->deleteNode(root, 80);\n\tcout << \"after delete\" << endl;\n\ttree->inorder(root);\n\n\tcout << endl << \"delete 30\" << endl;\n\ttree->deleteNode(root, 30);\n\tcout << \"after delete\" << endl;\n\ttree->inorder(root);\n\n\tcout << endl << \"second tree(create method)\" << endl;\n\tbinaryTreeNode *root1;\n\tvector<int> v{1,2,3,4,5,8,7};\n\ttree->createBST(root1, v);\n\tcout << \"Inorder traverse tree2\" << endl;\n\ttree->inorder(root1);\n\n\tif (ifIsA_BST(root1))\n\t\tcout << endl << \"It's a BST.\" << endl;\n\telse\n\t\tcout << endl << \"It's not a BST.\" << endl;\n\n\treturn 0;\n}\n```\n\n执行结果：\n<img src=\"https://blog-pics.nos-eastchina1.126.net/BST%E6%B5%8B%E8%AF%95%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C.jpg\" width=\"60%\" height=\"50%\">\n\n# 总结\n以上对二叉搜索树（BST）的结构，性质，基本方法包括：创建、插入、删除、查找等，以及其他一些功能函数做了较为详细的分析，相信大家对BST已经有了更多的认识。\n在学习BST的时候，递归是避免不了要理解的东西，想要理解递归，就要找到递归中最核心的代码部分，其余都是为了走向那里所做的流程处理，只不过是自己调用了自己，然后再从核心返回，一层一层调用回去。\n\n# 参考链接\n[BST的基本操作](https://www.geeksforgeeks.org/binary-search-tree-set-2-delete/)\n[判断是否是BST的方法](https://www.geeksforgeeks.org/a-program-to-check-if-a-binary-tree-is-bst-or-not/)\n[一个很好的学习数据结构和算法的网站(左右旋转）](http://www.algolist.net/Data_structures/Binary_search_tree/Removal)\n\n\n","slug":"BST","published":1,"updated":"2018-12-05T02:42:04.370Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyoig8ip0000pq0jfyagvm6d","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>今天来说说经典数据结构之一，二叉搜索树（BST）。<br>在学习过链表后，再来看二叉树的实现会轻松不少，因为都包含了很多指针操作，同为通过指针指向连接起来的数据结构。建议先把链表吃透，再来看树的实现。</p>\n<h1 id=\"什么是二叉搜索树\"><a href=\"#什么是二叉搜索树\" class=\"headerlink\" title=\"什么是二叉搜索树\"></a>什么是二叉搜索树</h1><p>二叉搜索树（Binary Search Tree），简称BST，也称为二叉搜索树、有序二叉树或排序二叉树，是指一棵<strong>空树</strong>或者具有下列性质的二叉树：<br><a id=\"more\"></a></p>\n<blockquote>\n<p>1、若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；<br>2、若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；<br>3、任意节点的左、右子树也分别为二叉查找树；<br>4、没有键值相等的节点。</p>\n</blockquote>\n<p>下图是否是一颗二叉搜索树呢？<br><img src=\"https://blog-pics.nos-eastchina1.126.net/%E4%B8%80%E4%B8%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.jpg\" width=\"40%\" height=\"50%\"><br>    答案是否，因为左子树的最大节点4比根节点3要大，不符合性质1，这个在接下来的<code>如何判断是否为BST</code>中还会讨论到。<br>    二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低。平均查找复杂度为 O(log n)，查找的效率和树的高度成正比，在最坏情况下为O(n)，这时二叉树退化成一条线。<br>    下面就和我开始一起构建一颗二叉搜索树吧！</p>\n<h1 id=\"二叉搜索树的方法们\"><a href=\"#二叉搜索树的方法们\" class=\"headerlink\" title=\"二叉搜索树的方法们\"></a>二叉搜索树的方法们</h1><p>BST的方法包括创建、查找、插入、删除和左旋右旋等，今天主要说说前几项。</p>\n<h2 id=\"BST节点的结构\"><a href=\"#BST节点的结构\" class=\"headerlink\" title=\"BST节点的结构\"></a>BST节点的结构</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">binaryTreeNode</span> </span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> item;  <span class=\"comment\">// 节点内容</span></span><br><span class=\"line\">\tbinaryTreeNode *l_child, *r_child;  <span class=\"comment\">// 左孩子和右孩子的指针</span></span><br><span class=\"line\">\tbinaryTreeNode(<span class=\"keyword\">int</span> item):item(item),l_child(<span class=\"literal\">NULL</span>),r_child(<span class=\"literal\">NULL</span>) &#123; &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这里为了方便讲解，暂定二叉树的节点元素为int类型，实际开发中一般会换成特定的结构体。</p>\n<h2 id=\"定义一个BST类\"><a href=\"#定义一个BST类\" class=\"headerlink\" title=\"定义一个BST类\"></a>定义一个BST类</h2><p>为了方便以后添加树的新方法，定义一个名为binaryTree的类，如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;set&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">binaryTree</span> </span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">set</span>&lt;<span class=\"keyword\">int</span>&gt; elemSet;  <span class=\"comment\">// 存放树中已有元素</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">ifExistsElement</span><span class=\"params\">(<span class=\"keyword\">int</span> elem)</span></span>;  <span class=\"comment\">// 是否存在一个元素</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tbinaryTree() &#123; &#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">createBST</span><span class=\"params\">(binaryTreeNode * &amp;root, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;v)</span></span>;  <span class=\"comment\">// 创建一个BST</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">inorder</span><span class=\"params\">(binaryTreeNode *root)</span></span>;  <span class=\"comment\">// 中序遍历</span></span><br><span class=\"line\">\t<span class=\"function\">binaryTreeNode *<span class=\"title\">insert</span><span class=\"params\">(binaryTreeNode *root, <span class=\"keyword\">int</span> item)</span></span>;  <span class=\"comment\">// 插入</span></span><br><span class=\"line\">\t<span class=\"function\">binaryTreeNode *<span class=\"title\">searchNode</span><span class=\"params\">(binaryTreeNode *root, <span class=\"keyword\">int</span> value)</span></span>;  <span class=\"comment\">// 查找节点</span></span><br><span class=\"line\">\t<span class=\"function\">binaryTreeNode *<span class=\"title\">leftRotation</span><span class=\"params\">(binaryTreeNode *root, binaryTreeNode *node)</span></span>;  <span class=\"comment\">// 左旋</span></span><br><span class=\"line\">\t<span class=\"function\">binaryTreeNode *<span class=\"title\">rightRotation</span><span class=\"params\">(binaryTreeNode *root, binaryTreeNode *node)</span></span>;  <span class=\"comment\">// 右旋</span></span><br><span class=\"line\">\t<span class=\"function\">binaryTreeNode *<span class=\"title\">maxValueNode</span><span class=\"params\">(binaryTreeNode *root)</span></span>;  <span class=\"comment\">// 找到最小节点</span></span><br><span class=\"line\">\t<span class=\"function\">binaryTreeNode *<span class=\"title\">minValueNode</span><span class=\"params\">(binaryTreeNode *root)</span></span>;  <span class=\"comment\">// 找到最大节点</span></span><br><span class=\"line\">\t<span class=\"function\">binaryTreeNode *<span class=\"title\">deleteNode</span><span class=\"params\">(binaryTreeNode *root, <span class=\"keyword\">int</span> delete_item)</span></span>;   <span class=\"comment\">// 删除节点</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"插入节点\"><a href=\"#插入节点\" class=\"headerlink\" title=\"插入节点\"></a>插入节点</h2><p>插入操作分两步：</p>\n<ol>\n<li>找到要插入父节点的位置；</li>\n<li>比较与该结点的大小，并插入。</li>\n</ol>\n<p>如何找到要插入的父节点位置，这里我们可以使用递归较为方便；在做插入操作时需要注意的是，当树为<strong>空</strong>时，需要申请一个新节点，并将其作为结果返回。<em>为什么不直接改变根节点的指向，让它直接指向新节点呢？</em>那样就需要用到二级指针，复杂化原有的逻辑；这样做能保持方法实现的一致性，只不过在一棵树为空树时，插入节点后要获取其返回值才行；同时还需考虑节点是否重复。<br>    ⁃    <strong>代码如下：</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 插入一个节点  */</span></span><br><span class=\"line\">binaryTreeNode *binaryTree::insert(binaryTreeNode *root, <span class=\"keyword\">int</span> item)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 检查是否元素重复</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ifExistsElement(item))</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"element %d exists\\n\"</span>, item);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> root;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (root == <span class=\"literal\">NULL</span>)  <span class=\"comment\">// （核心代码）</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tbinaryTreeNode *temp = <span class=\"keyword\">new</span> binaryTreeNode(item);</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;elemSet.insert(item);  <span class=\"comment\">// 插入已有元素集合</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> temp;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (item &gt; root-&gt;item)</span><br><span class=\"line\">\t\troot-&gt;r_child = insert(root-&gt;r_child, item);</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\troot-&gt;l_child = insert(root-&gt;l_child, item);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过以上代码我们可以看到，其实插入操作的<strong><em>真正核心</em></strong>就在第一个<code>if (root == NULL)</code>中。不管树的状态如何，程序最后都会走到这一步，然后再逐步返回。这也正是递归程序的真正意义，最后的结果永远会回到最终的地方，那里才是核心代码，其他都是为了走到那里的流程。</p>\n<h2 id=\"BST的创建\"><a href=\"#BST的创建\" class=\"headerlink\" title=\"BST的创建\"></a>BST的创建</h2><p>有了插入操作，创建BST就很简单了，我们可以把想放到树中的元素先放在一个vector里，然后逐个调用insert方法来构建BST.<br><strong>代码如下：</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 创建一颗二叉树 */</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> binaryTree::createBST(binaryTreeNode* &amp;root, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;v)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (v.empty())</span><br><span class=\"line\">\t\troot = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> val : v)  <span class=\"comment\">// 这里用到C++11的新标准，在编译时要注意</span></span><br><span class=\"line\">\t\t\troot = insert(root, val);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"删除节点\"><a href=\"#删除节点\" class=\"headerlink\" title=\"删除节点\"></a>删除节点</h2><p>删除节点稍显复杂，需要分情况讨论：</p>\n<ol>\n<li>待删除节点没有孩子</li>\n<li>待删除节点有一个孩子</li>\n<li>待删除节点有两个孩子</li>\n</ol>\n<p>对于前两种情况很简单，分别用NIL和该孩子节点替换删除节点，再删除待删除节点即可；</p>\n<ul>\n<li>情况一<br><img src=\"https://blog-pics.nos-eastchina1.126.net/satuation1.png\" alt=\"satuation1\"></li>\n<li><p>情况二</p>\n<ul>\n<li><p>变化前<br><img src=\"https://blog-pics.nos-eastchina1.126.net/satuation2-1.png\" width=\"50%\" height=\"50%\"></p>\n</li>\n<li><p>变化后<br><img src=\"https://blog-pics.nos-eastchina1.126.net/satuation2-2.png\" width=\"50%\" height=\"50%\"></p>\n</li>\n</ul>\n</li>\n</ul>\n<p>如果删除节点有两个孩子，这种情况可以找到删除节点的<em><em>左孩子中最大节点</em></em>、或<em><em>右孩子中最小节点</em></em>替换待删除节点，再释放删除节点。如下图，要删除12：</p>\n<ul>\n<li><p>情况三</p>\n<ul>\n<li><p>变化前<br><img src=\"https://blog-pics.nos-eastchina1.126.net/satuation3-1.png\" width=\"50%\" height=\"50%\"></p>\n</li>\n<li><p>变化后<br><img src=\"https://blog-pics.nos-eastchina1.126.net/satuation3-2.png\" width=\"50%\" height=\"50%\"></p>\n</li>\n</ul>\n</li>\n</ul>\n<p>为什么可以这样做呢？正常的思路考虑就是：用左子树中最大节点替换根节点，由于它比所有左子树其他节点要大，而且比右子树中所有节点要小，故用其替换当前根节点不会使BST的性质发生变化；用右子树中最小节点也是同理。<br>和这个类似的操作还有二叉树的<strong>左旋</strong>的<strong>右旋</strong>，都利用了一个BST可以有多种<strong>呈现方式</strong>的特性。<br><strong>实现代码如下：</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">binaryTreeNode *binaryTree::deleteNode(binaryTreeNode *root, <span class=\"keyword\">int</span> value)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (root == <span class=\"literal\">NULL</span>)  <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (value &gt; root-&gt;item)</span><br><span class=\"line\">\t\troot-&gt;r_child = deleteNode(root-&gt;r_child, value);</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (value &lt; root-&gt;item)</span><br><span class=\"line\">\t\troot-&gt;l_child = deleteNode(root-&gt;l_child, value);</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 删除节点有一个孩子节点或无孩子节点（核心代码，最终调用的地方，然后再回调）</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (root-&gt;l_child == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tbinaryTreeNode *temp = root-&gt;r_child;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">delete</span>(root);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> temp;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (root-&gt;r_child == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tbinaryTreeNode *temp = root-&gt;l_child;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">delete</span>(root);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> temp;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 删除节点有两个孩子节点</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tbinaryTreeNode *leftChildMaxNode = maxValueNode(root-&gt;l_child);</span><br><span class=\"line\">\t\t\troot-&gt;item = leftChildMaxNode-&gt;item;</span><br><span class=\"line\">\t\t\troot-&gt;l_child = deleteNode(root-&gt;l_child, leftChildMaxNode-&gt;item);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码当删除节点有两个孩子时，首先用了左子树中最大节点替换了删除节点的内容，然后递归删除了左子树的最大节点，达到替换的目的。</p>\n<h2 id=\"其他一些功能方法\"><a href=\"#其他一些功能方法\" class=\"headerlink\" title=\"其他一些功能方法\"></a>其他一些功能方法</h2><ul>\n<li>找到BST的最大节点<br>– 找一颗BST的最大节点就是找到其<strong>最深的右孩子节点</strong>，找到最小节点也是同理，即找到其<strong>最深的左孩子节点</strong>，便不再赘述。</li>\n</ul>\n<p><strong>代码如下：</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">binaryTreeNode *binaryTree::maxValueNode(binaryTreeNode *root)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tbinaryTreeNode *cur = root;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cur-&gt;r_child)</span><br><span class=\"line\">\t\tcur = cur-&gt;r_child;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> cur;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>判断一个元素是否已存在</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 利用set的无重复元素的性质，判断一个元素是否在树中  */</span></span><br><span class=\"line\"><span class=\"keyword\">bool</span> binaryTree::ifExistsElement(<span class=\"keyword\">int</span> elem)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> pd = <span class=\"keyword\">this</span>-&gt;elemSet.begin(); pd != <span class=\"keyword\">this</span>-&gt;elemSet.end(); ++pd)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (*pd == elem) </span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>中序遍历<br>– 用递归的方法对一颗BST中序遍历（中根序遍历），中序遍历的结果是<strong>从小到大排好序</strong>的。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 中序遍历 */</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> binaryTree::inorder(binaryTreeNode *root)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (root != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tinorder(root-&gt;l_child);</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d \\t\"</span>, root-&gt;item);</span><br><span class=\"line\">\t\tinorder(root-&gt;r_child);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">return</span>;  <span class=\"comment\">// 可以不写，写了方便理解递归</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>判断一棵树是否为二叉搜索树的方法（非类方法）<br>– 要判断一颗二叉树树是不是BST，即要判断是否它的所有节点都满足：<ul>\n<li>左孩子中最大的节点小于当前节点；</li>\n<li>右孩子中最小的节点大于当前节点；</li>\n</ul>\n</li>\n</ul>\n<p><strong>代码如下：</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 判断一棵树是否为二叉搜索树（BST）*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">ifIsA_BST</span><span class=\"params\">(binaryTreeNode *root)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tbinaryTree *tree = <span class=\"keyword\">new</span> binaryTree();</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (root == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (root-&gt;l_child != <span class=\"literal\">NULL</span> &amp;&amp; tree-&gt;maxValueNode(root-&gt;l_child)-&gt;item &gt; root-&gt;item)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (root-&gt;r_child != <span class=\"literal\">NULL</span> &amp;&amp; tree-&gt;minValueNode(root-&gt;r_child)-&gt;item &lt; root-&gt;item)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!ifIsA_BST(root-&gt;l_child) || !ifIsA_BST(root-&gt;r_child))  <span class=\"comment\">// 递归做判断</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种方法不是最高效的，但比较容易理解，如果想了解更高效的方法，请参阅<a href=\"https://www.geeksforgeeks.org/a-program-to-check-if-a-binary-tree-is-bst-or-not/\" target=\"_blank\" rel=\"noopener\">判断是否是BST的方法</a></p>\n<ul>\n<li>寻找一个节点</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 寻找一个节点，返回该节点的指针，没找到返回NULL */</span></span><br><span class=\"line\">binaryTreeNode *binaryTree::searchNode(binaryTreeNode *root, <span class=\"keyword\">int</span> value)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (root != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (value == root-&gt;item)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> root;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (value &gt; root-&gt;item)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> searchNode(root-&gt;r_child, value);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (value &lt; root-&gt;item)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> searchNode(root-&gt;l_child, value);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"测试程序\"><a href=\"#测试程序\" class=\"headerlink\" title=\"测试程序\"></a>测试程序</h2><p>BST实现好了，下面来写代码测试它：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">/* Let us create following BST </span></span><br><span class=\"line\"><span class=\"comment\">     *         50 </span></span><br><span class=\"line\"><span class=\"comment\">     *      /     \\ </span></span><br><span class=\"line\"><span class=\"comment\">     *     30      70 </span></span><br><span class=\"line\"><span class=\"comment\">     *    /  \\    /  \\ </span></span><br><span class=\"line\"><span class=\"comment\">     *  20   40  60   80 */</span></span><br><span class=\"line\">\tbinaryTreeNode *root = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\tbinaryTree *tree = <span class=\"keyword\">new</span> binaryTree();</span><br><span class=\"line\">\troot = tree-&gt;insert(root, <span class=\"number\">50</span>);</span><br><span class=\"line\">\ttree-&gt;insert(root, <span class=\"number\">30</span>);</span><br><span class=\"line\">\ttree-&gt;insert(root, <span class=\"number\">20</span>);</span><br><span class=\"line\">\ttree-&gt;insert(root, <span class=\"number\">40</span>);</span><br><span class=\"line\">\ttree-&gt;insert(root, <span class=\"number\">70</span>);</span><br><span class=\"line\">\ttree-&gt;insert(root, <span class=\"number\">60</span>);</span><br><span class=\"line\">\ttree-&gt;insert(root, <span class=\"number\">80</span>);</span><br><span class=\"line\">\ttree-&gt;insert(root, <span class=\"number\">80</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Inorder traverse tree1\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\ttree-&gt;inorder(root);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span> &lt;&lt; <span class=\"string\">\"max is \"</span> &lt;&lt; tree-&gt;maxValueNode(root)-&gt;item &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"delete 80\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\ttree-&gt;deleteNode(root, <span class=\"number\">80</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"after delete\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\ttree-&gt;inorder(root);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span> &lt;&lt; <span class=\"string\">\"delete 30\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\ttree-&gt;deleteNode(root, <span class=\"number\">30</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"after delete\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\ttree-&gt;inorder(root);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span> &lt;&lt; <span class=\"string\">\"second tree(create method)\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\tbinaryTreeNode *root1;</span><br><span class=\"line\">\t<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; v&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">8</span>,<span class=\"number\">7</span>&#125;;</span><br><span class=\"line\">\ttree-&gt;createBST(root1, v);</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Inorder traverse tree2\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\ttree-&gt;inorder(root1);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ifIsA_BST(root1))</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span> &lt;&lt; <span class=\"string\">\"It's a BST.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span> &lt;&lt; <span class=\"string\">\"It's not a BST.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行结果：<br><img src=\"https://blog-pics.nos-eastchina1.126.net/BST%E6%B5%8B%E8%AF%95%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C.jpg\" width=\"60%\" height=\"50%\"></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>以上对二叉搜索树（BST）的结构，性质，基本方法包括：创建、插入、删除、查找等，以及其他一些功能函数做了较为详细的分析，相信大家对BST已经有了更多的认识。<br>在学习BST的时候，递归是避免不了要理解的东西，想要理解递归，就要找到递归中最核心的代码部分，其余都是为了走向那里所做的流程处理，只不过是自己调用了自己，然后再从核心返回，一层一层调用回去。</p>\n<h1 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h1><p><a href=\"https://www.geeksforgeeks.org/binary-search-tree-set-2-delete/\" target=\"_blank\" rel=\"noopener\">BST的基本操作</a><br><a href=\"https://www.geeksforgeeks.org/a-program-to-check-if-a-binary-tree-is-bst-or-not/\" target=\"_blank\" rel=\"noopener\">判断是否是BST的方法</a><br><a href=\"http://www.algolist.net/Data_structures/Binary_search_tree/Removal\" target=\"_blank\" rel=\"noopener\">一个很好的学习数据结构和算法的网站(左右旋转）</a></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>今天来说说经典数据结构之一，二叉搜索树（BST）。<br>在学习过链表后，再来看二叉树的实现会轻松不少，因为都包含了很多指针操作，同为通过指针指向连接起来的数据结构。建议先把链表吃透，再来看树的实现。</p>\n<h1 id=\"什么是二叉搜索树\"><a href=\"#什么是二叉搜索树\" class=\"headerlink\" title=\"什么是二叉搜索树\"></a>什么是二叉搜索树</h1><p>二叉搜索树（Binary Search Tree），简称BST，也称为二叉搜索树、有序二叉树或排序二叉树，是指一棵<strong>空树</strong>或者具有下列性质的二叉树：<br></p>","more":"<p></p>\n<blockquote>\n<p>1、若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；<br>2、若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；<br>3、任意节点的左、右子树也分别为二叉查找树；<br>4、没有键值相等的节点。</p>\n</blockquote>\n<p>下图是否是一颗二叉搜索树呢？<br><img src=\"https://blog-pics.nos-eastchina1.126.net/%E4%B8%80%E4%B8%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.jpg\" width=\"40%\" height=\"50%\"><br>    答案是否，因为左子树的最大节点4比根节点3要大，不符合性质1，这个在接下来的<code>如何判断是否为BST</code>中还会讨论到。<br>    二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低。平均查找复杂度为 O(log n)，查找的效率和树的高度成正比，在最坏情况下为O(n)，这时二叉树退化成一条线。<br>    下面就和我开始一起构建一颗二叉搜索树吧！</p>\n<h1 id=\"二叉搜索树的方法们\"><a href=\"#二叉搜索树的方法们\" class=\"headerlink\" title=\"二叉搜索树的方法们\"></a>二叉搜索树的方法们</h1><p>BST的方法包括创建、查找、插入、删除和左旋右旋等，今天主要说说前几项。</p>\n<h2 id=\"BST节点的结构\"><a href=\"#BST节点的结构\" class=\"headerlink\" title=\"BST节点的结构\"></a>BST节点的结构</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">binaryTreeNode</span> </span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> item;  <span class=\"comment\">// 节点内容</span></span><br><span class=\"line\">\tbinaryTreeNode *l_child, *r_child;  <span class=\"comment\">// 左孩子和右孩子的指针</span></span><br><span class=\"line\">\tbinaryTreeNode(<span class=\"keyword\">int</span> item):item(item),l_child(<span class=\"literal\">NULL</span>),r_child(<span class=\"literal\">NULL</span>) &#123; &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这里为了方便讲解，暂定二叉树的节点元素为int类型，实际开发中一般会换成特定的结构体。</p>\n<h2 id=\"定义一个BST类\"><a href=\"#定义一个BST类\" class=\"headerlink\" title=\"定义一个BST类\"></a>定义一个BST类</h2><p>为了方便以后添加树的新方法，定义一个名为binaryTree的类，如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;set&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">binaryTree</span> </span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">set</span>&lt;<span class=\"keyword\">int</span>&gt; elemSet;  <span class=\"comment\">// 存放树中已有元素</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">ifExistsElement</span><span class=\"params\">(<span class=\"keyword\">int</span> elem)</span></span>;  <span class=\"comment\">// 是否存在一个元素</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tbinaryTree() &#123; &#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">createBST</span><span class=\"params\">(binaryTreeNode * &amp;root, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;v)</span></span>;  <span class=\"comment\">// 创建一个BST</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">inorder</span><span class=\"params\">(binaryTreeNode *root)</span></span>;  <span class=\"comment\">// 中序遍历</span></span><br><span class=\"line\">\t<span class=\"function\">binaryTreeNode *<span class=\"title\">insert</span><span class=\"params\">(binaryTreeNode *root, <span class=\"keyword\">int</span> item)</span></span>;  <span class=\"comment\">// 插入</span></span><br><span class=\"line\">\t<span class=\"function\">binaryTreeNode *<span class=\"title\">searchNode</span><span class=\"params\">(binaryTreeNode *root, <span class=\"keyword\">int</span> value)</span></span>;  <span class=\"comment\">// 查找节点</span></span><br><span class=\"line\">\t<span class=\"function\">binaryTreeNode *<span class=\"title\">leftRotation</span><span class=\"params\">(binaryTreeNode *root, binaryTreeNode *node)</span></span>;  <span class=\"comment\">// 左旋</span></span><br><span class=\"line\">\t<span class=\"function\">binaryTreeNode *<span class=\"title\">rightRotation</span><span class=\"params\">(binaryTreeNode *root, binaryTreeNode *node)</span></span>;  <span class=\"comment\">// 右旋</span></span><br><span class=\"line\">\t<span class=\"function\">binaryTreeNode *<span class=\"title\">maxValueNode</span><span class=\"params\">(binaryTreeNode *root)</span></span>;  <span class=\"comment\">// 找到最小节点</span></span><br><span class=\"line\">\t<span class=\"function\">binaryTreeNode *<span class=\"title\">minValueNode</span><span class=\"params\">(binaryTreeNode *root)</span></span>;  <span class=\"comment\">// 找到最大节点</span></span><br><span class=\"line\">\t<span class=\"function\">binaryTreeNode *<span class=\"title\">deleteNode</span><span class=\"params\">(binaryTreeNode *root, <span class=\"keyword\">int</span> delete_item)</span></span>;   <span class=\"comment\">// 删除节点</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"插入节点\"><a href=\"#插入节点\" class=\"headerlink\" title=\"插入节点\"></a>插入节点</h2><p>插入操作分两步：</p>\n<ol>\n<li>找到要插入父节点的位置；</li>\n<li>比较与该结点的大小，并插入。</li>\n</ol>\n<p>如何找到要插入的父节点位置，这里我们可以使用递归较为方便；在做插入操作时需要注意的是，当树为<strong>空</strong>时，需要申请一个新节点，并将其作为结果返回。<em>为什么不直接改变根节点的指向，让它直接指向新节点呢？</em>那样就需要用到二级指针，复杂化原有的逻辑；这样做能保持方法实现的一致性，只不过在一棵树为空树时，插入节点后要获取其返回值才行；同时还需考虑节点是否重复。<br>    ⁃    <strong>代码如下：</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 插入一个节点  */</span></span><br><span class=\"line\">binaryTreeNode *binaryTree::insert(binaryTreeNode *root, <span class=\"keyword\">int</span> item)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 检查是否元素重复</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ifExistsElement(item))</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"element %d exists\\n\"</span>, item);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> root;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (root == <span class=\"literal\">NULL</span>)  <span class=\"comment\">// （核心代码）</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tbinaryTreeNode *temp = <span class=\"keyword\">new</span> binaryTreeNode(item);</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;elemSet.insert(item);  <span class=\"comment\">// 插入已有元素集合</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> temp;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (item &gt; root-&gt;item)</span><br><span class=\"line\">\t\troot-&gt;r_child = insert(root-&gt;r_child, item);</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\troot-&gt;l_child = insert(root-&gt;l_child, item);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过以上代码我们可以看到，其实插入操作的<strong><em>真正核心</em></strong>就在第一个<code>if (root == NULL)</code>中。不管树的状态如何，程序最后都会走到这一步，然后再逐步返回。这也正是递归程序的真正意义，最后的结果永远会回到最终的地方，那里才是核心代码，其他都是为了走到那里的流程。</p>\n<h2 id=\"BST的创建\"><a href=\"#BST的创建\" class=\"headerlink\" title=\"BST的创建\"></a>BST的创建</h2><p>有了插入操作，创建BST就很简单了，我们可以把想放到树中的元素先放在一个vector里，然后逐个调用insert方法来构建BST.<br><strong>代码如下：</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 创建一颗二叉树 */</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> binaryTree::createBST(binaryTreeNode* &amp;root, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;v)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (v.empty())</span><br><span class=\"line\">\t\troot = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> val : v)  <span class=\"comment\">// 这里用到C++11的新标准，在编译时要注意</span></span><br><span class=\"line\">\t\t\troot = insert(root, val);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"删除节点\"><a href=\"#删除节点\" class=\"headerlink\" title=\"删除节点\"></a>删除节点</h2><p>删除节点稍显复杂，需要分情况讨论：</p>\n<ol>\n<li>待删除节点没有孩子</li>\n<li>待删除节点有一个孩子</li>\n<li>待删除节点有两个孩子</li>\n</ol>\n<p>对于前两种情况很简单，分别用NIL和该孩子节点替换删除节点，再删除待删除节点即可；</p>\n<ul>\n<li>情况一<br><img src=\"https://blog-pics.nos-eastchina1.126.net/satuation1.png\" alt=\"satuation1\"></li>\n<li><p>情况二</p>\n<ul>\n<li><p>变化前<br><img src=\"https://blog-pics.nos-eastchina1.126.net/satuation2-1.png\" width=\"50%\" height=\"50%\"></p>\n</li>\n<li><p>变化后<br><img src=\"https://blog-pics.nos-eastchina1.126.net/satuation2-2.png\" width=\"50%\" height=\"50%\"></p>\n</li>\n</ul>\n</li>\n</ul>\n<p>如果删除节点有两个孩子，这种情况可以找到删除节点的<em><em>左孩子中最大节点</em></em>、或<em><em>右孩子中最小节点</em></em>替换待删除节点，再释放删除节点。如下图，要删除12：</p>\n<ul>\n<li><p>情况三</p>\n<ul>\n<li><p>变化前<br><img src=\"https://blog-pics.nos-eastchina1.126.net/satuation3-1.png\" width=\"50%\" height=\"50%\"></p>\n</li>\n<li><p>变化后<br><img src=\"https://blog-pics.nos-eastchina1.126.net/satuation3-2.png\" width=\"50%\" height=\"50%\"></p>\n</li>\n</ul>\n</li>\n</ul>\n<p>为什么可以这样做呢？正常的思路考虑就是：用左子树中最大节点替换根节点，由于它比所有左子树其他节点要大，而且比右子树中所有节点要小，故用其替换当前根节点不会使BST的性质发生变化；用右子树中最小节点也是同理。<br>和这个类似的操作还有二叉树的<strong>左旋</strong>的<strong>右旋</strong>，都利用了一个BST可以有多种<strong>呈现方式</strong>的特性。<br><strong>实现代码如下：</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">binaryTreeNode *binaryTree::deleteNode(binaryTreeNode *root, <span class=\"keyword\">int</span> value)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (root == <span class=\"literal\">NULL</span>)  <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (value &gt; root-&gt;item)</span><br><span class=\"line\">\t\troot-&gt;r_child = deleteNode(root-&gt;r_child, value);</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (value &lt; root-&gt;item)</span><br><span class=\"line\">\t\troot-&gt;l_child = deleteNode(root-&gt;l_child, value);</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 删除节点有一个孩子节点或无孩子节点（核心代码，最终调用的地方，然后再回调）</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (root-&gt;l_child == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tbinaryTreeNode *temp = root-&gt;r_child;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">delete</span>(root);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> temp;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (root-&gt;r_child == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tbinaryTreeNode *temp = root-&gt;l_child;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">delete</span>(root);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> temp;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 删除节点有两个孩子节点</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tbinaryTreeNode *leftChildMaxNode = maxValueNode(root-&gt;l_child);</span><br><span class=\"line\">\t\t\troot-&gt;item = leftChildMaxNode-&gt;item;</span><br><span class=\"line\">\t\t\troot-&gt;l_child = deleteNode(root-&gt;l_child, leftChildMaxNode-&gt;item);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码当删除节点有两个孩子时，首先用了左子树中最大节点替换了删除节点的内容，然后递归删除了左子树的最大节点，达到替换的目的。</p>\n<h2 id=\"其他一些功能方法\"><a href=\"#其他一些功能方法\" class=\"headerlink\" title=\"其他一些功能方法\"></a>其他一些功能方法</h2><ul>\n<li>找到BST的最大节点<br>– 找一颗BST的最大节点就是找到其<strong>最深的右孩子节点</strong>，找到最小节点也是同理，即找到其<strong>最深的左孩子节点</strong>，便不再赘述。</li>\n</ul>\n<p><strong>代码如下：</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">binaryTreeNode *binaryTree::maxValueNode(binaryTreeNode *root)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tbinaryTreeNode *cur = root;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cur-&gt;r_child)</span><br><span class=\"line\">\t\tcur = cur-&gt;r_child;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> cur;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>判断一个元素是否已存在</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 利用set的无重复元素的性质，判断一个元素是否在树中  */</span></span><br><span class=\"line\"><span class=\"keyword\">bool</span> binaryTree::ifExistsElement(<span class=\"keyword\">int</span> elem)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> pd = <span class=\"keyword\">this</span>-&gt;elemSet.begin(); pd != <span class=\"keyword\">this</span>-&gt;elemSet.end(); ++pd)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (*pd == elem) </span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>中序遍历<br>– 用递归的方法对一颗BST中序遍历（中根序遍历），中序遍历的结果是<strong>从小到大排好序</strong>的。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 中序遍历 */</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> binaryTree::inorder(binaryTreeNode *root)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (root != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tinorder(root-&gt;l_child);</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d \\t\"</span>, root-&gt;item);</span><br><span class=\"line\">\t\tinorder(root-&gt;r_child);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">return</span>;  <span class=\"comment\">// 可以不写，写了方便理解递归</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>判断一棵树是否为二叉搜索树的方法（非类方法）<br>– 要判断一颗二叉树树是不是BST，即要判断是否它的所有节点都满足：<ul>\n<li>左孩子中最大的节点小于当前节点；</li>\n<li>右孩子中最小的节点大于当前节点；</li>\n</ul>\n</li>\n</ul>\n<p><strong>代码如下：</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 判断一棵树是否为二叉搜索树（BST）*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">ifIsA_BST</span><span class=\"params\">(binaryTreeNode *root)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tbinaryTree *tree = <span class=\"keyword\">new</span> binaryTree();</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (root == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (root-&gt;l_child != <span class=\"literal\">NULL</span> &amp;&amp; tree-&gt;maxValueNode(root-&gt;l_child)-&gt;item &gt; root-&gt;item)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (root-&gt;r_child != <span class=\"literal\">NULL</span> &amp;&amp; tree-&gt;minValueNode(root-&gt;r_child)-&gt;item &lt; root-&gt;item)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!ifIsA_BST(root-&gt;l_child) || !ifIsA_BST(root-&gt;r_child))  <span class=\"comment\">// 递归做判断</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种方法不是最高效的，但比较容易理解，如果想了解更高效的方法，请参阅<a href=\"https://www.geeksforgeeks.org/a-program-to-check-if-a-binary-tree-is-bst-or-not/\" target=\"_blank\" rel=\"noopener\">判断是否是BST的方法</a></p>\n<ul>\n<li>寻找一个节点</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 寻找一个节点，返回该节点的指针，没找到返回NULL */</span></span><br><span class=\"line\">binaryTreeNode *binaryTree::searchNode(binaryTreeNode *root, <span class=\"keyword\">int</span> value)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (root != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (value == root-&gt;item)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> root;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (value &gt; root-&gt;item)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> searchNode(root-&gt;r_child, value);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (value &lt; root-&gt;item)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> searchNode(root-&gt;l_child, value);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"测试程序\"><a href=\"#测试程序\" class=\"headerlink\" title=\"测试程序\"></a>测试程序</h2><p>BST实现好了，下面来写代码测试它：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">/* Let us create following BST </span></span><br><span class=\"line\"><span class=\"comment\">     *         50 </span></span><br><span class=\"line\"><span class=\"comment\">     *      /     \\ </span></span><br><span class=\"line\"><span class=\"comment\">     *     30      70 </span></span><br><span class=\"line\"><span class=\"comment\">     *    /  \\    /  \\ </span></span><br><span class=\"line\"><span class=\"comment\">     *  20   40  60   80 */</span></span><br><span class=\"line\">\tbinaryTreeNode *root = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\tbinaryTree *tree = <span class=\"keyword\">new</span> binaryTree();</span><br><span class=\"line\">\troot = tree-&gt;insert(root, <span class=\"number\">50</span>);</span><br><span class=\"line\">\ttree-&gt;insert(root, <span class=\"number\">30</span>);</span><br><span class=\"line\">\ttree-&gt;insert(root, <span class=\"number\">20</span>);</span><br><span class=\"line\">\ttree-&gt;insert(root, <span class=\"number\">40</span>);</span><br><span class=\"line\">\ttree-&gt;insert(root, <span class=\"number\">70</span>);</span><br><span class=\"line\">\ttree-&gt;insert(root, <span class=\"number\">60</span>);</span><br><span class=\"line\">\ttree-&gt;insert(root, <span class=\"number\">80</span>);</span><br><span class=\"line\">\ttree-&gt;insert(root, <span class=\"number\">80</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Inorder traverse tree1\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\ttree-&gt;inorder(root);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span> &lt;&lt; <span class=\"string\">\"max is \"</span> &lt;&lt; tree-&gt;maxValueNode(root)-&gt;item &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"delete 80\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\ttree-&gt;deleteNode(root, <span class=\"number\">80</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"after delete\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\ttree-&gt;inorder(root);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span> &lt;&lt; <span class=\"string\">\"delete 30\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\ttree-&gt;deleteNode(root, <span class=\"number\">30</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"after delete\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\ttree-&gt;inorder(root);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span> &lt;&lt; <span class=\"string\">\"second tree(create method)\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\tbinaryTreeNode *root1;</span><br><span class=\"line\">\t<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; v&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">8</span>,<span class=\"number\">7</span>&#125;;</span><br><span class=\"line\">\ttree-&gt;createBST(root1, v);</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Inorder traverse tree2\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\ttree-&gt;inorder(root1);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ifIsA_BST(root1))</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span> &lt;&lt; <span class=\"string\">\"It's a BST.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span> &lt;&lt; <span class=\"string\">\"It's not a BST.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行结果：<br><img src=\"https://blog-pics.nos-eastchina1.126.net/BST%E6%B5%8B%E8%AF%95%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C.jpg\" width=\"60%\" height=\"50%\"></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>以上对二叉搜索树（BST）的结构，性质，基本方法包括：创建、插入、删除、查找等，以及其他一些功能函数做了较为详细的分析，相信大家对BST已经有了更多的认识。<br>在学习BST的时候，递归是避免不了要理解的东西，想要理解递归，就要找到递归中最核心的代码部分，其余都是为了走向那里所做的流程处理，只不过是自己调用了自己，然后再从核心返回，一层一层调用回去。</p>\n<h1 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h1><p><a href=\"https://www.geeksforgeeks.org/binary-search-tree-set-2-delete/\" target=\"_blank\" rel=\"noopener\">BST的基本操作</a><br><a href=\"https://www.geeksforgeeks.org/a-program-to-check-if-a-binary-tree-is-bst-or-not/\" target=\"_blank\" rel=\"noopener\">判断是否是BST的方法</a><br><a href=\"http://www.algolist.net/Data_structures/Binary_search_tree/Removal\" target=\"_blank\" rel=\"noopener\">一个很好的学习数据结构和算法的网站(左右旋转）</a></p>"},{"title":"好好的链表怎么就有环了！","date":"2018-11-08T03:17:40.000Z","_content":"## 什么是有环的链表\n今天我们来说下有环的**单链表**。什么是有环的链表呢？我们都知道，正常单链表最后一个节点的`next`指针指向的是`NULL`，但有环的链表就不一样了，它把尾节点的`next`指针指向了链表中的其他节点（可以是头节点，也可以是其他任何节点）。基本就长下面这样：\n<!-- more -->\n![我是萌萌的环形链表](https://blog-pics.nos-eastchina1.126.net/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E7%9A%84%E6%A8%A1%E6%A0%B7.jpg)\n如上图，本应是尾节点的7号节点却指向了2号节点，这样一来就让链表中存在了环。\n\n## 问题\n链表中有环以后呢，那么问题就来了。\n我们该如何判断一个链表**是否存在环**？如果存在我们又如何寻找链表中**环的入口**呢？如图一，环的入口是2号节点。下面我们就来一一解决这两个问题。\n\n## 是否存在环\n首先说第一个问题，我们讲解的范围仅限于单链表，如何判定其是否存在环？\n### 一般的思路\n设置两个快慢指针：`fast`、`slow`，都指向链表头。slow一次向前移动一步，fast移动两步，如果两者都没到NULL（有环链表也走不到NULL），而且fast和slow相遇了，则说明链表有环。因为两者的步长不同，如果链表有环，则二者必然会相遇，就是早晚的事。代码就不贴了，注意空链表的特殊情况即可。\n### 另一种思路\n在C++中有一种STL是`map`，在这里我们利用`map`的特性来解决这个问题。思路就是：初始化一个`键`为`链表节点指针`，`值`为`int`的一个`map`对象，从链表头开始遍历，每经过一个节点就把**以该节点指针为键对应的值**置1，因为map在初始化时默认值是0；然后在遍历的过程中如果比较出`键对应的值`为1的则说明链表有环。\n这个思路有点想哈希的思想，给每个指针一个对应值，看是否有重复。代码如下：\n* 链表节点结构：\n\n``` C\ntypedef struct ListNode {\n    int m_value;\n    ListNode *p_next;\n    ListNode(int x): m_value(x), p_next(NULL) { }\n}Link;\n```\n* 实现：\n\n``` C\nbool hasCycle(Link *head) {\n\tif (head == NULL)\n\t\treturn false;\n\n\tLink *cur = head;\n\n\tmap<Link *, int> mm;\n\twhile (cur)\n\t{\n\t\tif (mm[cur] == 0)  // default value of map's int type value is 0\n\t\t\tmm[cur] = 1;\n\t\telse\n\t\t\treturn true;\n\t\tcur = cur->p_next;\n\t}\n\treturn false;\n}\n```\n这样就可以判定链表中是否有环了。\n## 寻找环的入口\n接下来我们来说第二个问题，如何寻找环的入口？这个问题稍微麻烦一点，***要先找到fast和slow指针相遇节点meetnode，之后meetnode和头节点一起走再相遇的节点即是环的入口***。具体的证明过程就不详细说了，有兴趣的朋友可以看一下[有环链表的相关证明](https://my.oschina.net/u/2360415/blog/741253)，上面很详细的解释了这个结论的来由。知道了结论，代码写起来就很简单了：\n``` C\n    // 找到快慢指针的相遇节点\n    Link *findSlowAndFastMeetNode(Link *head) {\n        Link *slow = head;\n        Link *fast = head;\n\n        while (fast != NULL)\n        {\n            slow = slow->p_next;\n            fast = fast->p_next->p_next;\n\n            if (slow == fast)\n                return slow;\n        }\n        return NULL;\n    }\n\n    // 找到环的入口节点\n    Link *findCycleEntryNode(Link *head, Link *meetNode) {\n        if (meetNode == head)\n            return meetNode;\n        Link *cur = head;\n        while (1)\n        {\n            cur = cur->p_next;\n            meetNode = meetNode->p_next;\n            if (cur == meetNode)\n                return cur;\n        }\n    }\n```\n* 测试代码\n\n``` C\n    int main()\n{\n    int arr[] = {1,2,3,4,5,6,7};\n    Link *list1= createALinklist(arr, 7);\n\n    Link *cur = list1;  // make list1 a cycle linklist.\n    while (cur->p_next)\n        cur = cur->p_next;\n    cur->p_next = list1->p_next;\n\n    Solution s;\n    bool isCycleLinkList = s.hasCycle(list1);\n\n    if (isCycleLinkList)\n    {\n        cout << \"It's a cycle linklist.\" << endl;\n        Link *meetNode = s.findSlowAndFastMeetNode(list1);\n        Link *enrtyNode = s.findCycleEntryNode(list1, meetNode);\n        cout << \"entry node is \" << enrtyNode->m_value << endl;\n    }\n    else\n        cout << \"It's not a cycle linklist.\" << endl;\n\n\n\n    return 0;\n}\n```\n执行结果：\n![cyclelist-result](https://blog-pics.nos-eastchina1.126.net/cyclelist-result.jpg)\n\n由于此代码是提交到Leetcode的，所以把上面几个方法封装到了一个名为Solution的类中，关于链表的创建等基础知识请看我的这篇博客[你想要了解的单链表](https://edwardlu.tech/2018/10/31/single-linklist/)。\n\n关于有环链表的内容今天就说到这里了，有任何问题欢迎讨论！\n\n## 参考\n[链表问题集锦](http://wuchong.me/blog/2014/03/25/interview-link-questions/)\n[环形链表相关证明](https://my.oschina.net/u/2360415/blog/741253)\n","source":"_posts/CycleList.md","raw":"---\ntitle: 好好的链表怎么就有环了！\ndate: 2018-11-08 11:17:40\ntags: \n- 有环单链表\n- 算法\n- 数据结构\ncategories:\n- 算法\n---\n## 什么是有环的链表\n今天我们来说下有环的**单链表**。什么是有环的链表呢？我们都知道，正常单链表最后一个节点的`next`指针指向的是`NULL`，但有环的链表就不一样了，它把尾节点的`next`指针指向了链表中的其他节点（可以是头节点，也可以是其他任何节点）。基本就长下面这样：\n<!-- more -->\n![我是萌萌的环形链表](https://blog-pics.nos-eastchina1.126.net/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E7%9A%84%E6%A8%A1%E6%A0%B7.jpg)\n如上图，本应是尾节点的7号节点却指向了2号节点，这样一来就让链表中存在了环。\n\n## 问题\n链表中有环以后呢，那么问题就来了。\n我们该如何判断一个链表**是否存在环**？如果存在我们又如何寻找链表中**环的入口**呢？如图一，环的入口是2号节点。下面我们就来一一解决这两个问题。\n\n## 是否存在环\n首先说第一个问题，我们讲解的范围仅限于单链表，如何判定其是否存在环？\n### 一般的思路\n设置两个快慢指针：`fast`、`slow`，都指向链表头。slow一次向前移动一步，fast移动两步，如果两者都没到NULL（有环链表也走不到NULL），而且fast和slow相遇了，则说明链表有环。因为两者的步长不同，如果链表有环，则二者必然会相遇，就是早晚的事。代码就不贴了，注意空链表的特殊情况即可。\n### 另一种思路\n在C++中有一种STL是`map`，在这里我们利用`map`的特性来解决这个问题。思路就是：初始化一个`键`为`链表节点指针`，`值`为`int`的一个`map`对象，从链表头开始遍历，每经过一个节点就把**以该节点指针为键对应的值**置1，因为map在初始化时默认值是0；然后在遍历的过程中如果比较出`键对应的值`为1的则说明链表有环。\n这个思路有点想哈希的思想，给每个指针一个对应值，看是否有重复。代码如下：\n* 链表节点结构：\n\n``` C\ntypedef struct ListNode {\n    int m_value;\n    ListNode *p_next;\n    ListNode(int x): m_value(x), p_next(NULL) { }\n}Link;\n```\n* 实现：\n\n``` C\nbool hasCycle(Link *head) {\n\tif (head == NULL)\n\t\treturn false;\n\n\tLink *cur = head;\n\n\tmap<Link *, int> mm;\n\twhile (cur)\n\t{\n\t\tif (mm[cur] == 0)  // default value of map's int type value is 0\n\t\t\tmm[cur] = 1;\n\t\telse\n\t\t\treturn true;\n\t\tcur = cur->p_next;\n\t}\n\treturn false;\n}\n```\n这样就可以判定链表中是否有环了。\n## 寻找环的入口\n接下来我们来说第二个问题，如何寻找环的入口？这个问题稍微麻烦一点，***要先找到fast和slow指针相遇节点meetnode，之后meetnode和头节点一起走再相遇的节点即是环的入口***。具体的证明过程就不详细说了，有兴趣的朋友可以看一下[有环链表的相关证明](https://my.oschina.net/u/2360415/blog/741253)，上面很详细的解释了这个结论的来由。知道了结论，代码写起来就很简单了：\n``` C\n    // 找到快慢指针的相遇节点\n    Link *findSlowAndFastMeetNode(Link *head) {\n        Link *slow = head;\n        Link *fast = head;\n\n        while (fast != NULL)\n        {\n            slow = slow->p_next;\n            fast = fast->p_next->p_next;\n\n            if (slow == fast)\n                return slow;\n        }\n        return NULL;\n    }\n\n    // 找到环的入口节点\n    Link *findCycleEntryNode(Link *head, Link *meetNode) {\n        if (meetNode == head)\n            return meetNode;\n        Link *cur = head;\n        while (1)\n        {\n            cur = cur->p_next;\n            meetNode = meetNode->p_next;\n            if (cur == meetNode)\n                return cur;\n        }\n    }\n```\n* 测试代码\n\n``` C\n    int main()\n{\n    int arr[] = {1,2,3,4,5,6,7};\n    Link *list1= createALinklist(arr, 7);\n\n    Link *cur = list1;  // make list1 a cycle linklist.\n    while (cur->p_next)\n        cur = cur->p_next;\n    cur->p_next = list1->p_next;\n\n    Solution s;\n    bool isCycleLinkList = s.hasCycle(list1);\n\n    if (isCycleLinkList)\n    {\n        cout << \"It's a cycle linklist.\" << endl;\n        Link *meetNode = s.findSlowAndFastMeetNode(list1);\n        Link *enrtyNode = s.findCycleEntryNode(list1, meetNode);\n        cout << \"entry node is \" << enrtyNode->m_value << endl;\n    }\n    else\n        cout << \"It's not a cycle linklist.\" << endl;\n\n\n\n    return 0;\n}\n```\n执行结果：\n![cyclelist-result](https://blog-pics.nos-eastchina1.126.net/cyclelist-result.jpg)\n\n由于此代码是提交到Leetcode的，所以把上面几个方法封装到了一个名为Solution的类中，关于链表的创建等基础知识请看我的这篇博客[你想要了解的单链表](https://edwardlu.tech/2018/10/31/single-linklist/)。\n\n关于有环链表的内容今天就说到这里了，有任何问题欢迎讨论！\n\n## 参考\n[链表问题集锦](http://wuchong.me/blog/2014/03/25/interview-link-questions/)\n[环形链表相关证明](https://my.oschina.net/u/2360415/blog/741253)\n","slug":"CycleList","published":1,"updated":"2018-12-05T02:42:26.392Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyoig8is0001pq0jcvij0f55","content":"<h2 id=\"什么是有环的链表\"><a href=\"#什么是有环的链表\" class=\"headerlink\" title=\"什么是有环的链表\"></a>什么是有环的链表</h2><p>今天我们来说下有环的<strong>单链表</strong>。什么是有环的链表呢？我们都知道，正常单链表最后一个节点的<code>next</code>指针指向的是<code>NULL</code>，但有环的链表就不一样了，它把尾节点的<code>next</code>指针指向了链表中的其他节点（可以是头节点，也可以是其他任何节点）。基本就长下面这样：<br><a id=\"more\"></a><br><img src=\"https://blog-pics.nos-eastchina1.126.net/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E7%9A%84%E6%A8%A1%E6%A0%B7.jpg\" alt=\"我是萌萌的环形链表\"><br>如上图，本应是尾节点的7号节点却指向了2号节点，这样一来就让链表中存在了环。</p>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>链表中有环以后呢，那么问题就来了。<br>我们该如何判断一个链表<strong>是否存在环</strong>？如果存在我们又如何寻找链表中<strong>环的入口</strong>呢？如图一，环的入口是2号节点。下面我们就来一一解决这两个问题。</p>\n<h2 id=\"是否存在环\"><a href=\"#是否存在环\" class=\"headerlink\" title=\"是否存在环\"></a>是否存在环</h2><p>首先说第一个问题，我们讲解的范围仅限于单链表，如何判定其是否存在环？</p>\n<h3 id=\"一般的思路\"><a href=\"#一般的思路\" class=\"headerlink\" title=\"一般的思路\"></a>一般的思路</h3><p>设置两个快慢指针：<code>fast</code>、<code>slow</code>，都指向链表头。slow一次向前移动一步，fast移动两步，如果两者都没到NULL（有环链表也走不到NULL），而且fast和slow相遇了，则说明链表有环。因为两者的步长不同，如果链表有环，则二者必然会相遇，就是早晚的事。代码就不贴了，注意空链表的特殊情况即可。</p>\n<h3 id=\"另一种思路\"><a href=\"#另一种思路\" class=\"headerlink\" title=\"另一种思路\"></a>另一种思路</h3><p>在C++中有一种STL是<code>map</code>，在这里我们利用<code>map</code>的特性来解决这个问题。思路就是：初始化一个<code>键</code>为<code>链表节点指针</code>，<code>值</code>为<code>int</code>的一个<code>map</code>对象，从链表头开始遍历，每经过一个节点就把<strong>以该节点指针为键对应的值</strong>置1，因为map在初始化时默认值是0；然后在遍历的过程中如果比较出<code>键对应的值</code>为1的则说明链表有环。<br>这个思路有点想哈希的思想，给每个指针一个对应值，看是否有重复。代码如下：</p>\n<ul>\n<li>链表节点结构：</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> m_value;</span><br><span class=\"line\">    ListNode *p_next;</span><br><span class=\"line\">    ListNode(<span class=\"keyword\">int</span> x): m_value(x), p_next(<span class=\"literal\">NULL</span>) &#123; &#125;</span><br><span class=\"line\">&#125;Link;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>实现：</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">hasCycle</span><span class=\"params\">(Link *head)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (head == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tLink *cur = head;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">map</span>&lt;Link *, <span class=\"keyword\">int</span>&gt; mm;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cur)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (mm[cur] == <span class=\"number\">0</span>)  <span class=\"comment\">// default value of map's int type value is 0</span></span><br><span class=\"line\">\t\t\tmm[cur] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\tcur = cur-&gt;p_next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样就可以判定链表中是否有环了。</p>\n<h2 id=\"寻找环的入口\"><a href=\"#寻找环的入口\" class=\"headerlink\" title=\"寻找环的入口\"></a>寻找环的入口</h2><p>接下来我们来说第二个问题，如何寻找环的入口？这个问题稍微麻烦一点，<strong><em>要先找到fast和slow指针相遇节点meetnode，之后meetnode和头节点一起走再相遇的节点即是环的入口</em></strong>。具体的证明过程就不详细说了，有兴趣的朋友可以看一下<a href=\"https://my.oschina.net/u/2360415/blog/741253\" target=\"_blank\" rel=\"noopener\">有环链表的相关证明</a>，上面很详细的解释了这个结论的来由。知道了结论，代码写起来就很简单了：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 找到快慢指针的相遇节点</span></span><br><span class=\"line\"><span class=\"function\">Link *<span class=\"title\">findSlowAndFastMeetNode</span><span class=\"params\">(Link *head)</span> </span>&#123;</span><br><span class=\"line\">    Link *slow = head;</span><br><span class=\"line\">    Link *fast = head;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (fast != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        slow = slow-&gt;p_next;</span><br><span class=\"line\">        fast = fast-&gt;p_next-&gt;p_next;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (slow == fast)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> slow;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 找到环的入口节点</span></span><br><span class=\"line\"><span class=\"function\">Link *<span class=\"title\">findCycleEntryNode</span><span class=\"params\">(Link *head, Link *meetNode)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (meetNode == head)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> meetNode;</span><br><span class=\"line\">    Link *cur = head;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cur = cur-&gt;p_next;</span><br><span class=\"line\">        meetNode = meetNode-&gt;p_next;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cur == meetNode)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> cur;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>测试代码</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> arr[] = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>&#125;;</span><br><span class=\"line\">    Link *list1= createALinklist(arr, <span class=\"number\">7</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    Link *cur = list1;  <span class=\"comment\">// make list1 a cycle linklist.</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (cur-&gt;p_next)</span><br><span class=\"line\">        cur = cur-&gt;p_next;</span><br><span class=\"line\">    cur-&gt;p_next = list1-&gt;p_next;</span><br><span class=\"line\"></span><br><span class=\"line\">    Solution s;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> isCycleLinkList = s.hasCycle(list1);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isCycleLinkList)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"It's a cycle linklist.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        Link *meetNode = s.findSlowAndFastMeetNode(list1);</span><br><span class=\"line\">        Link *enrtyNode = s.findCycleEntryNode(list1, meetNode);</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"entry node is \"</span> &lt;&lt; enrtyNode-&gt;m_value &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"It's not a cycle linklist.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行结果：<br><img src=\"https://blog-pics.nos-eastchina1.126.net/cyclelist-result.jpg\" alt=\"cyclelist-result\"></p>\n<p>由于此代码是提交到Leetcode的，所以把上面几个方法封装到了一个名为Solution的类中，关于链表的创建等基础知识请看我的这篇博客<a href=\"https://edwardlu.tech/2018/10/31/single-linklist/\" target=\"_blank\" rel=\"noopener\">你想要了解的单链表</a>。</p>\n<p>关于有环链表的内容今天就说到这里了，有任何问题欢迎讨论！</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://wuchong.me/blog/2014/03/25/interview-link-questions/\" target=\"_blank\" rel=\"noopener\">链表问题集锦</a><br><a href=\"https://my.oschina.net/u/2360415/blog/741253\" target=\"_blank\" rel=\"noopener\">环形链表相关证明</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"什么是有环的链表\"><a href=\"#什么是有环的链表\" class=\"headerlink\" title=\"什么是有环的链表\"></a>什么是有环的链表</h2><p>今天我们来说下有环的<strong>单链表</strong>。什么是有环的链表呢？我们都知道，正常单链表最后一个节点的<code>next</code>指针指向的是<code>NULL</code>，但有环的链表就不一样了，它把尾节点的<code>next</code>指针指向了链表中的其他节点（可以是头节点，也可以是其他任何节点）。基本就长下面这样：<br></p>","more":"<br><img src=\"https://blog-pics.nos-eastchina1.126.net/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E7%9A%84%E6%A8%A1%E6%A0%B7.jpg\" alt=\"我是萌萌的环形链表\"><br>如上图，本应是尾节点的7号节点却指向了2号节点，这样一来就让链表中存在了环。<p></p>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>链表中有环以后呢，那么问题就来了。<br>我们该如何判断一个链表<strong>是否存在环</strong>？如果存在我们又如何寻找链表中<strong>环的入口</strong>呢？如图一，环的入口是2号节点。下面我们就来一一解决这两个问题。</p>\n<h2 id=\"是否存在环\"><a href=\"#是否存在环\" class=\"headerlink\" title=\"是否存在环\"></a>是否存在环</h2><p>首先说第一个问题，我们讲解的范围仅限于单链表，如何判定其是否存在环？</p>\n<h3 id=\"一般的思路\"><a href=\"#一般的思路\" class=\"headerlink\" title=\"一般的思路\"></a>一般的思路</h3><p>设置两个快慢指针：<code>fast</code>、<code>slow</code>，都指向链表头。slow一次向前移动一步，fast移动两步，如果两者都没到NULL（有环链表也走不到NULL），而且fast和slow相遇了，则说明链表有环。因为两者的步长不同，如果链表有环，则二者必然会相遇，就是早晚的事。代码就不贴了，注意空链表的特殊情况即可。</p>\n<h3 id=\"另一种思路\"><a href=\"#另一种思路\" class=\"headerlink\" title=\"另一种思路\"></a>另一种思路</h3><p>在C++中有一种STL是<code>map</code>，在这里我们利用<code>map</code>的特性来解决这个问题。思路就是：初始化一个<code>键</code>为<code>链表节点指针</code>，<code>值</code>为<code>int</code>的一个<code>map</code>对象，从链表头开始遍历，每经过一个节点就把<strong>以该节点指针为键对应的值</strong>置1，因为map在初始化时默认值是0；然后在遍历的过程中如果比较出<code>键对应的值</code>为1的则说明链表有环。<br>这个思路有点想哈希的思想，给每个指针一个对应值，看是否有重复。代码如下：</p>\n<ul>\n<li>链表节点结构：</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> m_value;</span><br><span class=\"line\">    ListNode *p_next;</span><br><span class=\"line\">    ListNode(<span class=\"keyword\">int</span> x): m_value(x), p_next(<span class=\"literal\">NULL</span>) &#123; &#125;</span><br><span class=\"line\">&#125;Link;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>实现：</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">hasCycle</span><span class=\"params\">(Link *head)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (head == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tLink *cur = head;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">map</span>&lt;Link *, <span class=\"keyword\">int</span>&gt; mm;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cur)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (mm[cur] == <span class=\"number\">0</span>)  <span class=\"comment\">// default value of map's int type value is 0</span></span><br><span class=\"line\">\t\t\tmm[cur] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\tcur = cur-&gt;p_next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样就可以判定链表中是否有环了。</p>\n<h2 id=\"寻找环的入口\"><a href=\"#寻找环的入口\" class=\"headerlink\" title=\"寻找环的入口\"></a>寻找环的入口</h2><p>接下来我们来说第二个问题，如何寻找环的入口？这个问题稍微麻烦一点，<strong><em>要先找到fast和slow指针相遇节点meetnode，之后meetnode和头节点一起走再相遇的节点即是环的入口</em></strong>。具体的证明过程就不详细说了，有兴趣的朋友可以看一下<a href=\"https://my.oschina.net/u/2360415/blog/741253\" target=\"_blank\" rel=\"noopener\">有环链表的相关证明</a>，上面很详细的解释了这个结论的来由。知道了结论，代码写起来就很简单了：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 找到快慢指针的相遇节点</span></span><br><span class=\"line\"><span class=\"function\">Link *<span class=\"title\">findSlowAndFastMeetNode</span><span class=\"params\">(Link *head)</span> </span>&#123;</span><br><span class=\"line\">    Link *slow = head;</span><br><span class=\"line\">    Link *fast = head;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (fast != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        slow = slow-&gt;p_next;</span><br><span class=\"line\">        fast = fast-&gt;p_next-&gt;p_next;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (slow == fast)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> slow;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 找到环的入口节点</span></span><br><span class=\"line\"><span class=\"function\">Link *<span class=\"title\">findCycleEntryNode</span><span class=\"params\">(Link *head, Link *meetNode)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (meetNode == head)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> meetNode;</span><br><span class=\"line\">    Link *cur = head;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cur = cur-&gt;p_next;</span><br><span class=\"line\">        meetNode = meetNode-&gt;p_next;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cur == meetNode)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> cur;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>测试代码</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> arr[] = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>&#125;;</span><br><span class=\"line\">    Link *list1= createALinklist(arr, <span class=\"number\">7</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    Link *cur = list1;  <span class=\"comment\">// make list1 a cycle linklist.</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (cur-&gt;p_next)</span><br><span class=\"line\">        cur = cur-&gt;p_next;</span><br><span class=\"line\">    cur-&gt;p_next = list1-&gt;p_next;</span><br><span class=\"line\"></span><br><span class=\"line\">    Solution s;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> isCycleLinkList = s.hasCycle(list1);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isCycleLinkList)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"It's a cycle linklist.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        Link *meetNode = s.findSlowAndFastMeetNode(list1);</span><br><span class=\"line\">        Link *enrtyNode = s.findCycleEntryNode(list1, meetNode);</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"entry node is \"</span> &lt;&lt; enrtyNode-&gt;m_value &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"It's not a cycle linklist.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行结果：<br><img src=\"https://blog-pics.nos-eastchina1.126.net/cyclelist-result.jpg\" alt=\"cyclelist-result\"></p>\n<p>由于此代码是提交到Leetcode的，所以把上面几个方法封装到了一个名为Solution的类中，关于链表的创建等基础知识请看我的这篇博客<a href=\"https://edwardlu.tech/2018/10/31/single-linklist/\" target=\"_blank\" rel=\"noopener\">你想要了解的单链表</a>。</p>\n<p>关于有环链表的内容今天就说到这里了，有任何问题欢迎讨论！</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://wuchong.me/blog/2014/03/25/interview-link-questions/\" target=\"_blank\" rel=\"noopener\">链表问题集锦</a><br><a href=\"https://my.oschina.net/u/2360415/blog/741253\" target=\"_blank\" rel=\"noopener\">环形链表相关证明</a></p>"},{"title":"使用动态规划解决最长公共子序列（LCS）问题","date":"2018-12-04T07:30:33.000Z","_content":"# 前言\n动态规划（*Dynamic Programming*）这个词在大学的算法课上就曾学习过，但有多少人能真正把它掌握了呢？反正当时的我是一脸那啥的，光会死记硬背那些概念性的东西了。今天就让我们从一个实际问题出发，真正把动态规划的思想吃透。本文不会过多说明DP的概念，主要是结合*最长公共子序列*的问题用实例说明DP在解决问题上有什么优势，为什么用这种方法能提高效率。<!-- more -->\n\n# 最长公共子序列问题（*Longest Common Subsequence*）\n最长公共子序列指的是两个字符串最长的相同部分，而不必是连续的。举个例子，有两个字符串A和B：\n\n``` C\nstring A = \"ABCD\";\nstring B = \"AKCD\";\n```\n\n那么A和B的LCS为**`ACD`**。\n最长公共子序列和最长公共子串的区别在于：子序列不必是连续的，而子串必须是，所以上例中的最长公共子串是**`CD`**。\n\n## 一般思路\n\n### 两种情况\n解决LSC问题需要用到递归，这里用*LCS（s1，s2）*表示字符串s1和s2的最长公共子序列。还是上面的两个字符串A和B，要找到最长公共子序列，即*LCS(\"ABCD\", \"AKCD\")*，首先要比较两个字符串的第一个字符是否相同，这里显然是相同的，都是 `'A'`, 这样二者的最长公共子序列就变成了：`'A'` + *LCS(\"BCD\", \"KCD\")*;\n接下来，`'BCD'`, `'KCD'`的首字母不同了，这种情况下要分别求出*LCS(\"CD\", \"KCD\")*和*LCS(\"BCD\", \"CD\")*，然后取二者中最长的那个作为结果。然后继续递归直到字符串为空，即可找出A和B的LCS了。\n\n### 优化方法\n不过需要优化的地方在于：每次计算子串的LCS时都要生成新字符串，这样很浪费空间，可以给LCS方法加两个参数i1，i2，分别表示指向s1，s2当前比较到的字符，如LCS(\"ABCD\", \"AKCD\", 0, 0)表示从头开始比较：\n<img src=\"https://blog-pics.nos-eastchina1.126.net/LCS_DP/LCS%E6%8C%87%E9%92%88%E5%9B%BE.jpg\" width=\"30%\" height=\"30%\">\n如此，便不难写出如下代码：\n\n``` C\nstring LCS(string s1, string s2)\n{\n    string lcs = helper(s1, s2, 0, 0);\n    return lcs;\n}\n\nstring helper(string s1, string s2, unsigned long int i1, unsigned long int i2)\n{\n    // 如果字符串为空，直接返回空串\n    if (s1.length() == i1 || s2.length() == i2) {\n        return \"\";\n    }\n\n\n    // 如果比较的第一个字母相同，递归返回第一个字母加后面剩余的最长公共子序列\n    if (s1[i1] == s2[i2]) {\n        return s1[i1] + helper(s1, s2, i1 + 1, i2 + 1);\n    }\n\n    // 如果不同，返回下面两种结果中较长的一个\n    string result;\n    string resultA = helper(s1, s2, i1 + 1, i2);\n    string resultB = helper(s1, s2, i1, i2 + 1);\n    if (resultA.length() >= resultB.length())\n        result = resultA;\n    else\n        result = resultB;\n    return result;\n}\n```\n\n### 存在问题\n\n上述解法的确能够得到正确答案，但由于多次对相同的字符串进行递归计算LCS（既然这样，为什么我们不把中间计算过的结果记录下来呢？），从时间效率上来讲是很低的，在两个字符串很短的时候不会很明显，但如果一旦遇到两个稍长的字符串，等待时间将会很漫长，故这不是一种好的方法。如此我们便引入了动态规划，减少计算量，提高效率。\n\n\n# 动态规划\n\n## 为什么要用动态规划\n\n我们可以看到，在求解LCS问题时，初始问题会转化成更小的“子问题”，而“子问题”的解决方法和初始问题以及子问题的子问题都是一样的，这种性质称之为 **“重叠子问题”** ，即是说每一个子问题并不是新的问题，而是解决方法完全一样的仅仅是规模不一样的问题；\n另外，在求解LCS的过程中，能够利用相同字符连接上剩余字符串的最长公共子序列，这样来得到最终答案，这一性质又被称作 **“最优子结构”** ；\n而具有以上两种性质的问题，最适合的算法就是“动态规划”，下面，我们就来用动态规划来对此问题进行优化。\n\n## 动态规划算法的核心\n有一句话很好地描述出了该算法的核心：\n> Those who cannot remember the past are condemned to repeat it.\n\n在[一位大牛的博客](https://blog.csdn.net/u013309870/article/details/75193592)上看到过一个很形象的比喻：\n```\nA * \"1+1+1+1+1+1+1+1 =？\" *\n\nA : \"上面等式的值是多少\"\nB : *计算* \"8!\"\n\nA *在上面等式的左边写上 \"1+\" *\nA : \"此时等式的值为多少\"\nB : *quickly* \"9!\"\nA : \"你怎么这么快就知道答案了\"\nA : \"只要在8的基础上加1就行了\"\nA : \"所以你不用重新计算因为你记住了第一个等式的值为8!动态规划算法也可以说是 '记住求过的解来节省时间'\"\n```\n\n所以动态规划的核心就是把需要重复计算的耗时操作记录下来，即记录*_已经解决过的子问题的解_*。\n\n## 优化代码\n\n按照这个思路，我们可以对以上的代码进行如下优化。\n* 定义一个二维的字符串数组memo，维数为s1.length() ✖️ s2.length()，将其添加到helper函数的参数中；\n* 在每次计算LCS操作前，先到memo数组中找是否已经存在该结果，如果存在直接返回该结果，如果不存在，则先计算结果并把结果保存到memo相应的位置，再返回该结果。\n\n这样一来，便可以省去很多重复计算子问题的时间。\n下面是用动态规划方法优化后的代码：\n``` C\nstring LCS(string s1, string s2)\n{\n    // 初始化一个二维string数组\n    string **memo = new string*[s1.length()];\n    for (unsigned long i = 0; i < s1.length(); ++i)\n        memo[i] = new string[s2.length()];\n\n    string lcs = helper_DP(s1, s2, 0, 0， memo);\n    return lcs;  \n}\n\nstring helper_DP(string s1, string s2, unsigned long int i1, unsigned long int i2, string **memo)\n{\n    // 如果字符串为空，直接返回空串\n    if (s1.length() == i1 || s2.length() == i2) {\n        return \"\";\n    }\n\n    // 如果结果已经在memo中，无需再次计算，直接返回\n    if (!memo[i1][i2].empty())\n        return memo[i1][i2];\n\n    // 如果比较的第一个字母相同，递归返回第一个字母加后面剩余的最长公共子序列\n    if (s1[i1] == s2[i2]) {\n        memo[i1][i2] = s1[i1] + helper_DP(s1, s2, i1 + 1, i2 + 1, memo);\n        return memo[i1][i2];\n    }\n\n    // 如果不同，返回下面两种结果中较长的一个\n    string result;\n    string resultA = helper_DP(s1, s2, i1 + 1, i2, memo);\n    string resultB = helper_DP(s1, s2, i1, i2 + 1, memo);\n    if (resultA.length() >= resultB.length())\n        result = resultA;\n    else\n        result = resultB;\n    // 先保存结果，再返回\n    memo[i1][i2] = result;\n    return result;\n}\n```\n测试程序：\n``` C\nint main()\n{\n    string one = \"I've been waiting for you for too long\";\n    string two = \"I was waiting for you for so long\";\n    string lcs = LCS(one, two);\n    cout << \"It's \" << lcs << endl;\n\n    return 0;\n}\n```\n运行结果：\n<img src=\"https://blog-pics.nos-eastchina1.126.net/LCS_DP/DP%E6%96%B9%E6%B3%95%E7%9A%84%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.jpg\">\n**注：**利用动态规划的运行时间很快，但如果用第一种方法，运行这个需要计算很长时间，有兴趣的可以自己试一下。\n\n# 总结\n其实除LCS问题外还有很多类似可以用DP解决的问题，如Fibonacci数列某一项的值等，方法类似，再次不做赘述，有兴趣可移步[Fibonacci数列的某一项](https://github.com/416207298/Codes/blob/master/algorithms/LCS_DP/09s-斐波那契数列.c)。\n在工作的过程中，由于基本都是一些业务流程上的开发，很少会用到算法，动态规划就更未曾使用过。但是算法在某些时候解决一些具有特定性质的问题时，确实是很有威力的，而一些看似很复杂的算法其实本质上都来源于生活中简单的道理，多了解一些算法，就相当于更了解生活，何乐而不为呢？\n\n# 参考链接\n[CS Dojo](https://www.youtube.com/watch?v=4SP_AY7GGxw&list=PLMK6fRb_qvYiMbz_Yzd0hvS99YiBi-0Ck&t=1293s&index=3)\n[https://blog.csdn.net/u013309870/article/details/75193592](https://blog.csdn.net/u013309870/article/details/75193592)\n\n","source":"_posts/LSC-DP.md","raw":"---\ntitle: 使用动态规划解决最长公共子序列（LCS）问题\ndate: 2018-12-04 15:30:33\ntags:\n- 动态规划\n- 算法\n- 最长公共子序列\ncategories: \n- 算法\n---\n# 前言\n动态规划（*Dynamic Programming*）这个词在大学的算法课上就曾学习过，但有多少人能真正把它掌握了呢？反正当时的我是一脸那啥的，光会死记硬背那些概念性的东西了。今天就让我们从一个实际问题出发，真正把动态规划的思想吃透。本文不会过多说明DP的概念，主要是结合*最长公共子序列*的问题用实例说明DP在解决问题上有什么优势，为什么用这种方法能提高效率。<!-- more -->\n\n# 最长公共子序列问题（*Longest Common Subsequence*）\n最长公共子序列指的是两个字符串最长的相同部分，而不必是连续的。举个例子，有两个字符串A和B：\n\n``` C\nstring A = \"ABCD\";\nstring B = \"AKCD\";\n```\n\n那么A和B的LCS为**`ACD`**。\n最长公共子序列和最长公共子串的区别在于：子序列不必是连续的，而子串必须是，所以上例中的最长公共子串是**`CD`**。\n\n## 一般思路\n\n### 两种情况\n解决LSC问题需要用到递归，这里用*LCS（s1，s2）*表示字符串s1和s2的最长公共子序列。还是上面的两个字符串A和B，要找到最长公共子序列，即*LCS(\"ABCD\", \"AKCD\")*，首先要比较两个字符串的第一个字符是否相同，这里显然是相同的，都是 `'A'`, 这样二者的最长公共子序列就变成了：`'A'` + *LCS(\"BCD\", \"KCD\")*;\n接下来，`'BCD'`, `'KCD'`的首字母不同了，这种情况下要分别求出*LCS(\"CD\", \"KCD\")*和*LCS(\"BCD\", \"CD\")*，然后取二者中最长的那个作为结果。然后继续递归直到字符串为空，即可找出A和B的LCS了。\n\n### 优化方法\n不过需要优化的地方在于：每次计算子串的LCS时都要生成新字符串，这样很浪费空间，可以给LCS方法加两个参数i1，i2，分别表示指向s1，s2当前比较到的字符，如LCS(\"ABCD\", \"AKCD\", 0, 0)表示从头开始比较：\n<img src=\"https://blog-pics.nos-eastchina1.126.net/LCS_DP/LCS%E6%8C%87%E9%92%88%E5%9B%BE.jpg\" width=\"30%\" height=\"30%\">\n如此，便不难写出如下代码：\n\n``` C\nstring LCS(string s1, string s2)\n{\n    string lcs = helper(s1, s2, 0, 0);\n    return lcs;\n}\n\nstring helper(string s1, string s2, unsigned long int i1, unsigned long int i2)\n{\n    // 如果字符串为空，直接返回空串\n    if (s1.length() == i1 || s2.length() == i2) {\n        return \"\";\n    }\n\n\n    // 如果比较的第一个字母相同，递归返回第一个字母加后面剩余的最长公共子序列\n    if (s1[i1] == s2[i2]) {\n        return s1[i1] + helper(s1, s2, i1 + 1, i2 + 1);\n    }\n\n    // 如果不同，返回下面两种结果中较长的一个\n    string result;\n    string resultA = helper(s1, s2, i1 + 1, i2);\n    string resultB = helper(s1, s2, i1, i2 + 1);\n    if (resultA.length() >= resultB.length())\n        result = resultA;\n    else\n        result = resultB;\n    return result;\n}\n```\n\n### 存在问题\n\n上述解法的确能够得到正确答案，但由于多次对相同的字符串进行递归计算LCS（既然这样，为什么我们不把中间计算过的结果记录下来呢？），从时间效率上来讲是很低的，在两个字符串很短的时候不会很明显，但如果一旦遇到两个稍长的字符串，等待时间将会很漫长，故这不是一种好的方法。如此我们便引入了动态规划，减少计算量，提高效率。\n\n\n# 动态规划\n\n## 为什么要用动态规划\n\n我们可以看到，在求解LCS问题时，初始问题会转化成更小的“子问题”，而“子问题”的解决方法和初始问题以及子问题的子问题都是一样的，这种性质称之为 **“重叠子问题”** ，即是说每一个子问题并不是新的问题，而是解决方法完全一样的仅仅是规模不一样的问题；\n另外，在求解LCS的过程中，能够利用相同字符连接上剩余字符串的最长公共子序列，这样来得到最终答案，这一性质又被称作 **“最优子结构”** ；\n而具有以上两种性质的问题，最适合的算法就是“动态规划”，下面，我们就来用动态规划来对此问题进行优化。\n\n## 动态规划算法的核心\n有一句话很好地描述出了该算法的核心：\n> Those who cannot remember the past are condemned to repeat it.\n\n在[一位大牛的博客](https://blog.csdn.net/u013309870/article/details/75193592)上看到过一个很形象的比喻：\n```\nA * \"1+1+1+1+1+1+1+1 =？\" *\n\nA : \"上面等式的值是多少\"\nB : *计算* \"8!\"\n\nA *在上面等式的左边写上 \"1+\" *\nA : \"此时等式的值为多少\"\nB : *quickly* \"9!\"\nA : \"你怎么这么快就知道答案了\"\nA : \"只要在8的基础上加1就行了\"\nA : \"所以你不用重新计算因为你记住了第一个等式的值为8!动态规划算法也可以说是 '记住求过的解来节省时间'\"\n```\n\n所以动态规划的核心就是把需要重复计算的耗时操作记录下来，即记录*_已经解决过的子问题的解_*。\n\n## 优化代码\n\n按照这个思路，我们可以对以上的代码进行如下优化。\n* 定义一个二维的字符串数组memo，维数为s1.length() ✖️ s2.length()，将其添加到helper函数的参数中；\n* 在每次计算LCS操作前，先到memo数组中找是否已经存在该结果，如果存在直接返回该结果，如果不存在，则先计算结果并把结果保存到memo相应的位置，再返回该结果。\n\n这样一来，便可以省去很多重复计算子问题的时间。\n下面是用动态规划方法优化后的代码：\n``` C\nstring LCS(string s1, string s2)\n{\n    // 初始化一个二维string数组\n    string **memo = new string*[s1.length()];\n    for (unsigned long i = 0; i < s1.length(); ++i)\n        memo[i] = new string[s2.length()];\n\n    string lcs = helper_DP(s1, s2, 0, 0， memo);\n    return lcs;  \n}\n\nstring helper_DP(string s1, string s2, unsigned long int i1, unsigned long int i2, string **memo)\n{\n    // 如果字符串为空，直接返回空串\n    if (s1.length() == i1 || s2.length() == i2) {\n        return \"\";\n    }\n\n    // 如果结果已经在memo中，无需再次计算，直接返回\n    if (!memo[i1][i2].empty())\n        return memo[i1][i2];\n\n    // 如果比较的第一个字母相同，递归返回第一个字母加后面剩余的最长公共子序列\n    if (s1[i1] == s2[i2]) {\n        memo[i1][i2] = s1[i1] + helper_DP(s1, s2, i1 + 1, i2 + 1, memo);\n        return memo[i1][i2];\n    }\n\n    // 如果不同，返回下面两种结果中较长的一个\n    string result;\n    string resultA = helper_DP(s1, s2, i1 + 1, i2, memo);\n    string resultB = helper_DP(s1, s2, i1, i2 + 1, memo);\n    if (resultA.length() >= resultB.length())\n        result = resultA;\n    else\n        result = resultB;\n    // 先保存结果，再返回\n    memo[i1][i2] = result;\n    return result;\n}\n```\n测试程序：\n``` C\nint main()\n{\n    string one = \"I've been waiting for you for too long\";\n    string two = \"I was waiting for you for so long\";\n    string lcs = LCS(one, two);\n    cout << \"It's \" << lcs << endl;\n\n    return 0;\n}\n```\n运行结果：\n<img src=\"https://blog-pics.nos-eastchina1.126.net/LCS_DP/DP%E6%96%B9%E6%B3%95%E7%9A%84%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.jpg\">\n**注：**利用动态规划的运行时间很快，但如果用第一种方法，运行这个需要计算很长时间，有兴趣的可以自己试一下。\n\n# 总结\n其实除LCS问题外还有很多类似可以用DP解决的问题，如Fibonacci数列某一项的值等，方法类似，再次不做赘述，有兴趣可移步[Fibonacci数列的某一项](https://github.com/416207298/Codes/blob/master/algorithms/LCS_DP/09s-斐波那契数列.c)。\n在工作的过程中，由于基本都是一些业务流程上的开发，很少会用到算法，动态规划就更未曾使用过。但是算法在某些时候解决一些具有特定性质的问题时，确实是很有威力的，而一些看似很复杂的算法其实本质上都来源于生活中简单的道理，多了解一些算法，就相当于更了解生活，何乐而不为呢？\n\n# 参考链接\n[CS Dojo](https://www.youtube.com/watch?v=4SP_AY7GGxw&list=PLMK6fRb_qvYiMbz_Yzd0hvS99YiBi-0Ck&t=1293s&index=3)\n[https://blog.csdn.net/u013309870/article/details/75193592](https://blog.csdn.net/u013309870/article/details/75193592)\n\n","slug":"LSC-DP","published":1,"updated":"2019-07-28T05:20:21.862Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyoig8iv0004pq0j5qoobkwm","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>动态规划（<em>Dynamic Programming</em>）这个词在大学的算法课上就曾学习过，但有多少人能真正把它掌握了呢？反正当时的我是一脸那啥的，光会死记硬背那些概念性的东西了。今天就让我们从一个实际问题出发，真正把动态规划的思想吃透。本文不会过多说明DP的概念，主要是结合<em>最长公共子序列</em>的问题用实例说明DP在解决问题上有什么优势，为什么用这种方法能提高效率。<a id=\"more\"></a></p>\n<h1 id=\"最长公共子序列问题（Longest-Common-Subsequence）\"><a href=\"#最长公共子序列问题（Longest-Common-Subsequence）\" class=\"headerlink\" title=\"最长公共子序列问题（Longest Common Subsequence）\"></a>最长公共子序列问题（<em>Longest Common Subsequence</em>）</h1><p>最长公共子序列指的是两个字符串最长的相同部分，而不必是连续的。举个例子，有两个字符串A和B：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">string</span> A = <span class=\"string\">\"ABCD\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">string</span> B = <span class=\"string\">\"AKCD\"</span>;</span><br></pre></td></tr></table></figure>\n<p>那么A和B的LCS为<strong><code>ACD</code></strong>。<br>最长公共子序列和最长公共子串的区别在于：子序列不必是连续的，而子串必须是，所以上例中的最长公共子串是<strong><code>CD</code></strong>。</p>\n<h2 id=\"一般思路\"><a href=\"#一般思路\" class=\"headerlink\" title=\"一般思路\"></a>一般思路</h2><h3 id=\"两种情况\"><a href=\"#两种情况\" class=\"headerlink\" title=\"两种情况\"></a>两种情况</h3><p>解决LSC问题需要用到递归，这里用<em>LCS（s1，s2）</em>表示字符串s1和s2的最长公共子序列。还是上面的两个字符串A和B，要找到最长公共子序列，即<em>LCS(“ABCD”, “AKCD”)</em>，首先要比较两个字符串的第一个字符是否相同，这里显然是相同的，都是 <code>&#39;A&#39;</code>, 这样二者的最长公共子序列就变成了：<code>&#39;A&#39;</code> + <em>LCS(“BCD”, “KCD”)</em>;<br>接下来，<code>&#39;BCD&#39;</code>, <code>&#39;KCD&#39;</code>的首字母不同了，这种情况下要分别求出<em>LCS(“CD”, “KCD”)</em>和<em>LCS(“BCD”, “CD”)</em>，然后取二者中最长的那个作为结果。然后继续递归直到字符串为空，即可找出A和B的LCS了。</p>\n<h3 id=\"优化方法\"><a href=\"#优化方法\" class=\"headerlink\" title=\"优化方法\"></a>优化方法</h3><p>不过需要优化的地方在于：每次计算子串的LCS时都要生成新字符串，这样很浪费空间，可以给LCS方法加两个参数i1，i2，分别表示指向s1，s2当前比较到的字符，如LCS(“ABCD”, “AKCD”, 0, 0)表示从头开始比较：<br><img src=\"https://blog-pics.nos-eastchina1.126.net/LCS_DP/LCS%E6%8C%87%E9%92%88%E5%9B%BE.jpg\" width=\"30%\" height=\"30%\"><br>如此，便不难写出如下代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">LCS</span><span class=\"params\">(<span class=\"built_in\">string</span> s1, <span class=\"built_in\">string</span> s2)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> lcs = helper(s1, s2, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> lcs;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">helper</span><span class=\"params\">(<span class=\"built_in\">string</span> s1, <span class=\"built_in\">string</span> s2, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">int</span> i1, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">int</span> i2)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果字符串为空，直接返回空串</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s1.length() == i1 || s2.length() == i2) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果比较的第一个字母相同，递归返回第一个字母加后面剩余的最长公共子序列</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s1[i1] == s2[i2]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s1[i1] + helper(s1, s2, i1 + <span class=\"number\">1</span>, i2 + <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果不同，返回下面两种结果中较长的一个</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> result;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> resultA = helper(s1, s2, i1 + <span class=\"number\">1</span>, i2);</span><br><span class=\"line\">    <span class=\"built_in\">string</span> resultB = helper(s1, s2, i1, i2 + <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (resultA.length() &gt;= resultB.length())</span><br><span class=\"line\">        result = resultA;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        result = resultB;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"存在问题\"><a href=\"#存在问题\" class=\"headerlink\" title=\"存在问题\"></a>存在问题</h3><p>上述解法的确能够得到正确答案，但由于多次对相同的字符串进行递归计算LCS（既然这样，为什么我们不把中间计算过的结果记录下来呢？），从时间效率上来讲是很低的，在两个字符串很短的时候不会很明显，但如果一旦遇到两个稍长的字符串，等待时间将会很漫长，故这不是一种好的方法。如此我们便引入了动态规划，减少计算量，提高效率。</p>\n<h1 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h1><h2 id=\"为什么要用动态规划\"><a href=\"#为什么要用动态规划\" class=\"headerlink\" title=\"为什么要用动态规划\"></a>为什么要用动态规划</h2><p>我们可以看到，在求解LCS问题时，初始问题会转化成更小的“子问题”，而“子问题”的解决方法和初始问题以及子问题的子问题都是一样的，这种性质称之为 <strong>“重叠子问题”</strong> ，即是说每一个子问题并不是新的问题，而是解决方法完全一样的仅仅是规模不一样的问题；<br>另外，在求解LCS的过程中，能够利用相同字符连接上剩余字符串的最长公共子序列，这样来得到最终答案，这一性质又被称作 <strong>“最优子结构”</strong> ；<br>而具有以上两种性质的问题，最适合的算法就是“动态规划”，下面，我们就来用动态规划来对此问题进行优化。</p>\n<h2 id=\"动态规划算法的核心\"><a href=\"#动态规划算法的核心\" class=\"headerlink\" title=\"动态规划算法的核心\"></a>动态规划算法的核心</h2><p>有一句话很好地描述出了该算法的核心：</p>\n<blockquote>\n<p>Those who cannot remember the past are condemned to repeat it.</p>\n</blockquote>\n<p>在<a href=\"https://blog.csdn.net/u013309870/article/details/75193592\" target=\"_blank\" rel=\"noopener\">一位大牛的博客</a>上看到过一个很形象的比喻：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A * &quot;1+1+1+1+1+1+1+1 =？&quot; *</span><br><span class=\"line\"></span><br><span class=\"line\">A : &quot;上面等式的值是多少&quot;</span><br><span class=\"line\">B : *计算* &quot;8!&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">A *在上面等式的左边写上 &quot;1+&quot; *</span><br><span class=\"line\">A : &quot;此时等式的值为多少&quot;</span><br><span class=\"line\">B : *quickly* &quot;9!&quot;</span><br><span class=\"line\">A : &quot;你怎么这么快就知道答案了&quot;</span><br><span class=\"line\">A : &quot;只要在8的基础上加1就行了&quot;</span><br><span class=\"line\">A : &quot;所以你不用重新计算因为你记住了第一个等式的值为8!动态规划算法也可以说是 &apos;记住求过的解来节省时间&apos;&quot;</span><br></pre></td></tr></table></figure></p>\n<p>所以动态规划的核心就是把需要重复计算的耗时操作记录下来，即记录<em><em>已经解决过的子问题的解</em></em>。</p>\n<h2 id=\"优化代码\"><a href=\"#优化代码\" class=\"headerlink\" title=\"优化代码\"></a>优化代码</h2><p>按照这个思路，我们可以对以上的代码进行如下优化。</p>\n<ul>\n<li>定义一个二维的字符串数组memo，维数为s1.length() ✖️ s2.length()，将其添加到helper函数的参数中；</li>\n<li>在每次计算LCS操作前，先到memo数组中找是否已经存在该结果，如果存在直接返回该结果，如果不存在，则先计算结果并把结果保存到memo相应的位置，再返回该结果。</li>\n</ul>\n<p>这样一来，便可以省去很多重复计算子问题的时间。<br>下面是用动态规划方法优化后的代码：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">LCS</span><span class=\"params\">(<span class=\"built_in\">string</span> s1, <span class=\"built_in\">string</span> s2)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化一个二维string数组</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> **memo = <span class=\"keyword\">new</span> <span class=\"built_in\">string</span>*[s1.length()];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> i = <span class=\"number\">0</span>; i &lt; s1.length(); ++i)</span><br><span class=\"line\">        memo[i] = <span class=\"keyword\">new</span> <span class=\"built_in\">string</span>[s2.length()];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">string</span> lcs = helper_DP(s1, s2, <span class=\"number\">0</span>, <span class=\"number\">0</span>， memo);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> lcs;  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">helper_DP</span><span class=\"params\">(<span class=\"built_in\">string</span> s1, <span class=\"built_in\">string</span> s2, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">int</span> i1, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">int</span> i2, <span class=\"built_in\">string</span> **memo)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果字符串为空，直接返回空串</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s1.length() == i1 || s2.length() == i2) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果结果已经在memo中，无需再次计算，直接返回</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!memo[i1][i2].empty())</span><br><span class=\"line\">        <span class=\"keyword\">return</span> memo[i1][i2];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果比较的第一个字母相同，递归返回第一个字母加后面剩余的最长公共子序列</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s1[i1] == s2[i2]) &#123;</span><br><span class=\"line\">        memo[i1][i2] = s1[i1] + helper_DP(s1, s2, i1 + <span class=\"number\">1</span>, i2 + <span class=\"number\">1</span>, memo);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> memo[i1][i2];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果不同，返回下面两种结果中较长的一个</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> result;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> resultA = helper_DP(s1, s2, i1 + <span class=\"number\">1</span>, i2, memo);</span><br><span class=\"line\">    <span class=\"built_in\">string</span> resultB = helper_DP(s1, s2, i1, i2 + <span class=\"number\">1</span>, memo);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (resultA.length() &gt;= resultB.length())</span><br><span class=\"line\">        result = resultA;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        result = resultB;</span><br><span class=\"line\">    <span class=\"comment\">// 先保存结果，再返回</span></span><br><span class=\"line\">    memo[i1][i2] = result;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>测试程序：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> one = <span class=\"string\">\"I've been waiting for you for too long\"</span>;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> two = <span class=\"string\">\"I was waiting for you for so long\"</span>;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> lcs = LCS(one, two);</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"It's \"</span> &lt;&lt; lcs &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行结果：<br><img src=\"https://blog-pics.nos-eastchina1.126.net/LCS_DP/DP%E6%96%B9%E6%B3%95%E7%9A%84%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.jpg\"><br><strong>注：</strong>利用动态规划的运行时间很快，但如果用第一种方法，运行这个需要计算很长时间，有兴趣的可以自己试一下。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>其实除LCS问题外还有很多类似可以用DP解决的问题，如Fibonacci数列某一项的值等，方法类似，再次不做赘述，有兴趣可移步<a href=\"https://github.com/416207298/Codes/blob/master/algorithms/LCS_DP/09s-斐波那契数列.c\" target=\"_blank\" rel=\"noopener\">Fibonacci数列的某一项</a>。<br>在工作的过程中，由于基本都是一些业务流程上的开发，很少会用到算法，动态规划就更未曾使用过。但是算法在某些时候解决一些具有特定性质的问题时，确实是很有威力的，而一些看似很复杂的算法其实本质上都来源于生活中简单的道理，多了解一些算法，就相当于更了解生活，何乐而不为呢？</p>\n<h1 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h1><p><a href=\"https://www.youtube.com/watch?v=4SP_AY7GGxw&amp;list=PLMK6fRb_qvYiMbz_Yzd0hvS99YiBi-0Ck&amp;t=1293s&amp;index=3\" target=\"_blank\" rel=\"noopener\">CS Dojo</a><br><a href=\"https://blog.csdn.net/u013309870/article/details/75193592\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/u013309870/article/details/75193592</a></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>动态规划（<em>Dynamic Programming</em>）这个词在大学的算法课上就曾学习过，但有多少人能真正把它掌握了呢？反正当时的我是一脸那啥的，光会死记硬背那些概念性的东西了。今天就让我们从一个实际问题出发，真正把动态规划的思想吃透。本文不会过多说明DP的概念，主要是结合<em>最长公共子序列</em>的问题用实例说明DP在解决问题上有什么优势，为什么用这种方法能提高效率。</p>","more":"<p></p>\n<h1 id=\"最长公共子序列问题（Longest-Common-Subsequence）\"><a href=\"#最长公共子序列问题（Longest-Common-Subsequence）\" class=\"headerlink\" title=\"最长公共子序列问题（Longest Common Subsequence）\"></a>最长公共子序列问题（<em>Longest Common Subsequence</em>）</h1><p>最长公共子序列指的是两个字符串最长的相同部分，而不必是连续的。举个例子，有两个字符串A和B：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">string</span> A = <span class=\"string\">\"ABCD\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">string</span> B = <span class=\"string\">\"AKCD\"</span>;</span><br></pre></td></tr></table></figure>\n<p>那么A和B的LCS为<strong><code>ACD</code></strong>。<br>最长公共子序列和最长公共子串的区别在于：子序列不必是连续的，而子串必须是，所以上例中的最长公共子串是<strong><code>CD</code></strong>。</p>\n<h2 id=\"一般思路\"><a href=\"#一般思路\" class=\"headerlink\" title=\"一般思路\"></a>一般思路</h2><h3 id=\"两种情况\"><a href=\"#两种情况\" class=\"headerlink\" title=\"两种情况\"></a>两种情况</h3><p>解决LSC问题需要用到递归，这里用<em>LCS（s1，s2）</em>表示字符串s1和s2的最长公共子序列。还是上面的两个字符串A和B，要找到最长公共子序列，即<em>LCS(“ABCD”, “AKCD”)</em>，首先要比较两个字符串的第一个字符是否相同，这里显然是相同的，都是 <code>&#39;A&#39;</code>, 这样二者的最长公共子序列就变成了：<code>&#39;A&#39;</code> + <em>LCS(“BCD”, “KCD”)</em>;<br>接下来，<code>&#39;BCD&#39;</code>, <code>&#39;KCD&#39;</code>的首字母不同了，这种情况下要分别求出<em>LCS(“CD”, “KCD”)</em>和<em>LCS(“BCD”, “CD”)</em>，然后取二者中最长的那个作为结果。然后继续递归直到字符串为空，即可找出A和B的LCS了。</p>\n<h3 id=\"优化方法\"><a href=\"#优化方法\" class=\"headerlink\" title=\"优化方法\"></a>优化方法</h3><p>不过需要优化的地方在于：每次计算子串的LCS时都要生成新字符串，这样很浪费空间，可以给LCS方法加两个参数i1，i2，分别表示指向s1，s2当前比较到的字符，如LCS(“ABCD”, “AKCD”, 0, 0)表示从头开始比较：<br><img src=\"https://blog-pics.nos-eastchina1.126.net/LCS_DP/LCS%E6%8C%87%E9%92%88%E5%9B%BE.jpg\" width=\"30%\" height=\"30%\"><br>如此，便不难写出如下代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">LCS</span><span class=\"params\">(<span class=\"built_in\">string</span> s1, <span class=\"built_in\">string</span> s2)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> lcs = helper(s1, s2, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> lcs;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">helper</span><span class=\"params\">(<span class=\"built_in\">string</span> s1, <span class=\"built_in\">string</span> s2, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">int</span> i1, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">int</span> i2)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果字符串为空，直接返回空串</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s1.length() == i1 || s2.length() == i2) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果比较的第一个字母相同，递归返回第一个字母加后面剩余的最长公共子序列</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s1[i1] == s2[i2]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s1[i1] + helper(s1, s2, i1 + <span class=\"number\">1</span>, i2 + <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果不同，返回下面两种结果中较长的一个</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> result;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> resultA = helper(s1, s2, i1 + <span class=\"number\">1</span>, i2);</span><br><span class=\"line\">    <span class=\"built_in\">string</span> resultB = helper(s1, s2, i1, i2 + <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (resultA.length() &gt;= resultB.length())</span><br><span class=\"line\">        result = resultA;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        result = resultB;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"存在问题\"><a href=\"#存在问题\" class=\"headerlink\" title=\"存在问题\"></a>存在问题</h3><p>上述解法的确能够得到正确答案，但由于多次对相同的字符串进行递归计算LCS（既然这样，为什么我们不把中间计算过的结果记录下来呢？），从时间效率上来讲是很低的，在两个字符串很短的时候不会很明显，但如果一旦遇到两个稍长的字符串，等待时间将会很漫长，故这不是一种好的方法。如此我们便引入了动态规划，减少计算量，提高效率。</p>\n<h1 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h1><h2 id=\"为什么要用动态规划\"><a href=\"#为什么要用动态规划\" class=\"headerlink\" title=\"为什么要用动态规划\"></a>为什么要用动态规划</h2><p>我们可以看到，在求解LCS问题时，初始问题会转化成更小的“子问题”，而“子问题”的解决方法和初始问题以及子问题的子问题都是一样的，这种性质称之为 <strong>“重叠子问题”</strong> ，即是说每一个子问题并不是新的问题，而是解决方法完全一样的仅仅是规模不一样的问题；<br>另外，在求解LCS的过程中，能够利用相同字符连接上剩余字符串的最长公共子序列，这样来得到最终答案，这一性质又被称作 <strong>“最优子结构”</strong> ；<br>而具有以上两种性质的问题，最适合的算法就是“动态规划”，下面，我们就来用动态规划来对此问题进行优化。</p>\n<h2 id=\"动态规划算法的核心\"><a href=\"#动态规划算法的核心\" class=\"headerlink\" title=\"动态规划算法的核心\"></a>动态规划算法的核心</h2><p>有一句话很好地描述出了该算法的核心：</p>\n<blockquote>\n<p>Those who cannot remember the past are condemned to repeat it.</p>\n</blockquote>\n<p>在<a href=\"https://blog.csdn.net/u013309870/article/details/75193592\" target=\"_blank\" rel=\"noopener\">一位大牛的博客</a>上看到过一个很形象的比喻：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A * &quot;1+1+1+1+1+1+1+1 =？&quot; *</span><br><span class=\"line\"></span><br><span class=\"line\">A : &quot;上面等式的值是多少&quot;</span><br><span class=\"line\">B : *计算* &quot;8!&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">A *在上面等式的左边写上 &quot;1+&quot; *</span><br><span class=\"line\">A : &quot;此时等式的值为多少&quot;</span><br><span class=\"line\">B : *quickly* &quot;9!&quot;</span><br><span class=\"line\">A : &quot;你怎么这么快就知道答案了&quot;</span><br><span class=\"line\">A : &quot;只要在8的基础上加1就行了&quot;</span><br><span class=\"line\">A : &quot;所以你不用重新计算因为你记住了第一个等式的值为8!动态规划算法也可以说是 &apos;记住求过的解来节省时间&apos;&quot;</span><br></pre></td></tr></table></figure></p>\n<p>所以动态规划的核心就是把需要重复计算的耗时操作记录下来，即记录<em><em>已经解决过的子问题的解</em></em>。</p>\n<h2 id=\"优化代码\"><a href=\"#优化代码\" class=\"headerlink\" title=\"优化代码\"></a>优化代码</h2><p>按照这个思路，我们可以对以上的代码进行如下优化。</p>\n<ul>\n<li>定义一个二维的字符串数组memo，维数为s1.length() ✖️ s2.length()，将其添加到helper函数的参数中；</li>\n<li>在每次计算LCS操作前，先到memo数组中找是否已经存在该结果，如果存在直接返回该结果，如果不存在，则先计算结果并把结果保存到memo相应的位置，再返回该结果。</li>\n</ul>\n<p>这样一来，便可以省去很多重复计算子问题的时间。<br>下面是用动态规划方法优化后的代码：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">LCS</span><span class=\"params\">(<span class=\"built_in\">string</span> s1, <span class=\"built_in\">string</span> s2)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化一个二维string数组</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> **memo = <span class=\"keyword\">new</span> <span class=\"built_in\">string</span>*[s1.length()];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> i = <span class=\"number\">0</span>; i &lt; s1.length(); ++i)</span><br><span class=\"line\">        memo[i] = <span class=\"keyword\">new</span> <span class=\"built_in\">string</span>[s2.length()];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">string</span> lcs = helper_DP(s1, s2, <span class=\"number\">0</span>, <span class=\"number\">0</span>， memo);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> lcs;  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">helper_DP</span><span class=\"params\">(<span class=\"built_in\">string</span> s1, <span class=\"built_in\">string</span> s2, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">int</span> i1, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">int</span> i2, <span class=\"built_in\">string</span> **memo)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果字符串为空，直接返回空串</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s1.length() == i1 || s2.length() == i2) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果结果已经在memo中，无需再次计算，直接返回</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!memo[i1][i2].empty())</span><br><span class=\"line\">        <span class=\"keyword\">return</span> memo[i1][i2];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果比较的第一个字母相同，递归返回第一个字母加后面剩余的最长公共子序列</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s1[i1] == s2[i2]) &#123;</span><br><span class=\"line\">        memo[i1][i2] = s1[i1] + helper_DP(s1, s2, i1 + <span class=\"number\">1</span>, i2 + <span class=\"number\">1</span>, memo);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> memo[i1][i2];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果不同，返回下面两种结果中较长的一个</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> result;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> resultA = helper_DP(s1, s2, i1 + <span class=\"number\">1</span>, i2, memo);</span><br><span class=\"line\">    <span class=\"built_in\">string</span> resultB = helper_DP(s1, s2, i1, i2 + <span class=\"number\">1</span>, memo);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (resultA.length() &gt;= resultB.length())</span><br><span class=\"line\">        result = resultA;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        result = resultB;</span><br><span class=\"line\">    <span class=\"comment\">// 先保存结果，再返回</span></span><br><span class=\"line\">    memo[i1][i2] = result;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>测试程序：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> one = <span class=\"string\">\"I've been waiting for you for too long\"</span>;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> two = <span class=\"string\">\"I was waiting for you for so long\"</span>;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> lcs = LCS(one, two);</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"It's \"</span> &lt;&lt; lcs &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行结果：<br><img src=\"https://blog-pics.nos-eastchina1.126.net/LCS_DP/DP%E6%96%B9%E6%B3%95%E7%9A%84%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.jpg\"><br><strong>注：</strong>利用动态规划的运行时间很快，但如果用第一种方法，运行这个需要计算很长时间，有兴趣的可以自己试一下。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>其实除LCS问题外还有很多类似可以用DP解决的问题，如Fibonacci数列某一项的值等，方法类似，再次不做赘述，有兴趣可移步<a href=\"https://github.com/416207298/Codes/blob/master/algorithms/LCS_DP/09s-斐波那契数列.c\" target=\"_blank\" rel=\"noopener\">Fibonacci数列的某一项</a>。<br>在工作的过程中，由于基本都是一些业务流程上的开发，很少会用到算法，动态规划就更未曾使用过。但是算法在某些时候解决一些具有特定性质的问题时，确实是很有威力的，而一些看似很复杂的算法其实本质上都来源于生活中简单的道理，多了解一些算法，就相当于更了解生活，何乐而不为呢？</p>\n<h1 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h1><p><a href=\"https://www.youtube.com/watch?v=4SP_AY7GGxw&amp;list=PLMK6fRb_qvYiMbz_Yzd0hvS99YiBi-0Ck&amp;t=1293s&amp;index=3\" target=\"_blank\" rel=\"noopener\">CS Dojo</a><br><a href=\"https://blog.csdn.net/u013309870/article/details/75193592\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/u013309870/article/details/75193592</a></p>"},{"title":"我会采更多的雏菊","date":"2019-07-29T14:44:18.000Z","_content":"如果我能够从头活过，\n我会试着犯更多的错。\n<!-- more -->\n\n我会放松一点，我会灵活一点。\n我会比这一趟过得傻。\n很少有什么事情能让我当真。\n\n我会疯狂一些，我会少讲点卫生。\n我会冒更多的险。我会更经常的旅行。\n我会爬更多的山，游更多的河，看更多的日落。\n我会多吃冰激凌，少吃豆子。\n我会惹更多的麻烦，可是不在想象中担忧。\n\n你看，我小心翼翼地稳健地理智地活着。\n一个又一个小时，一天又一天。\n\n噢，我有过难忘的时刻。\n如果我能够重来一次，我会要更多这样的时刻。\n\n事实上，我不需要别的什么，\n仅仅是时刻，一个接着一个。\n而不是每天都操心着以后的漫长日子。\n\n我曾经不论到哪里都不忘记带上：\n温度计，热水壶，雨衣和降落伞。\n\n如果我能够重来一次，\n我会到处走走，什么都试试，并且轻装上阵。\n如果我能够重头活过，\n我会延长打赤脚的时光。\n从尽早的春天到尽晚的秋天。\n\n我会更经常的逃学。\n我不会考那么高的分数，除非是一不小心。\n我会多骑些旋转木马，\n我会采更多的雏菊。\n——纳丁·斯特尔,时年87岁\n\n\n","source":"_posts/poet1-我会采更多的雏菊.md","raw":"---\ntitle: 我会采更多的雏菊\ndate: 2019-07-29 22:44:18\ntags: 诗歌/感悟/人生\ncategories: \n- 杂\n---\n如果我能够从头活过，\n我会试着犯更多的错。\n<!-- more -->\n\n我会放松一点，我会灵活一点。\n我会比这一趟过得傻。\n很少有什么事情能让我当真。\n\n我会疯狂一些，我会少讲点卫生。\n我会冒更多的险。我会更经常的旅行。\n我会爬更多的山，游更多的河，看更多的日落。\n我会多吃冰激凌，少吃豆子。\n我会惹更多的麻烦，可是不在想象中担忧。\n\n你看，我小心翼翼地稳健地理智地活着。\n一个又一个小时，一天又一天。\n\n噢，我有过难忘的时刻。\n如果我能够重来一次，我会要更多这样的时刻。\n\n事实上，我不需要别的什么，\n仅仅是时刻，一个接着一个。\n而不是每天都操心着以后的漫长日子。\n\n我曾经不论到哪里都不忘记带上：\n温度计，热水壶，雨衣和降落伞。\n\n如果我能够重来一次，\n我会到处走走，什么都试试，并且轻装上阵。\n如果我能够重头活过，\n我会延长打赤脚的时光。\n从尽早的春天到尽晚的秋天。\n\n我会更经常的逃学。\n我不会考那么高的分数，除非是一不小心。\n我会多骑些旋转木马，\n我会采更多的雏菊。\n——纳丁·斯特尔,时年87岁\n\n\n","slug":"poet1-我会采更多的雏菊","published":1,"updated":"2019-07-29T14:48:28.026Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyoig8iw0005pq0jqru6xs2y","content":"<p>如果我能够从头活过，<br>我会试着犯更多的错。<br><a id=\"more\"></a></p>\n<p>我会放松一点，我会灵活一点。<br>我会比这一趟过得傻。<br>很少有什么事情能让我当真。</p>\n<p>我会疯狂一些，我会少讲点卫生。<br>我会冒更多的险。我会更经常的旅行。<br>我会爬更多的山，游更多的河，看更多的日落。<br>我会多吃冰激凌，少吃豆子。<br>我会惹更多的麻烦，可是不在想象中担忧。</p>\n<p>你看，我小心翼翼地稳健地理智地活着。<br>一个又一个小时，一天又一天。</p>\n<p>噢，我有过难忘的时刻。<br>如果我能够重来一次，我会要更多这样的时刻。</p>\n<p>事实上，我不需要别的什么，<br>仅仅是时刻，一个接着一个。<br>而不是每天都操心着以后的漫长日子。</p>\n<p>我曾经不论到哪里都不忘记带上：<br>温度计，热水壶，雨衣和降落伞。</p>\n<p>如果我能够重来一次，<br>我会到处走走，什么都试试，并且轻装上阵。<br>如果我能够重头活过，<br>我会延长打赤脚的时光。<br>从尽早的春天到尽晚的秋天。</p>\n<p>我会更经常的逃学。<br>我不会考那么高的分数，除非是一不小心。<br>我会多骑些旋转木马，<br>我会采更多的雏菊。<br>——纳丁·斯特尔,时年87岁</p>\n","site":{"data":{}},"excerpt":"<p>如果我能够从头活过，<br>我会试着犯更多的错。<br></p>","more":"<p></p>\n<p>我会放松一点，我会灵活一点。<br>我会比这一趟过得傻。<br>很少有什么事情能让我当真。</p>\n<p>我会疯狂一些，我会少讲点卫生。<br>我会冒更多的险。我会更经常的旅行。<br>我会爬更多的山，游更多的河，看更多的日落。<br>我会多吃冰激凌，少吃豆子。<br>我会惹更多的麻烦，可是不在想象中担忧。</p>\n<p>你看，我小心翼翼地稳健地理智地活着。<br>一个又一个小时，一天又一天。</p>\n<p>噢，我有过难忘的时刻。<br>如果我能够重来一次，我会要更多这样的时刻。</p>\n<p>事实上，我不需要别的什么，<br>仅仅是时刻，一个接着一个。<br>而不是每天都操心着以后的漫长日子。</p>\n<p>我曾经不论到哪里都不忘记带上：<br>温度计，热水壶，雨衣和降落伞。</p>\n<p>如果我能够重来一次，<br>我会到处走走，什么都试试，并且轻装上阵。<br>如果我能够重头活过，<br>我会延长打赤脚的时光。<br>从尽早的春天到尽晚的秋天。</p>\n<p>我会更经常的逃学。<br>我不会考那么高的分数，除非是一不小心。<br>我会多骑些旋转木马，<br>我会采更多的雏菊。<br>——纳丁·斯特尔,时年87岁</p>"},{"title":"再谈线程安全","date":"2019-07-29T13:55:23.000Z","_content":"\n## 背景\n今天在工作中，遇到了很恼人的错误`“double free or corruption”`，随着程序运行着，不一定何时就会出现，就像一颗定时炸弹，好气呀。网上找说是原因可能有两种：\n<!-- more -->\n> 1. 字面意思，释放两次。不过这种错误太过低级，一般都不会犯；\n> 2. 内存越界也会报这个错误。比如访问了超过数组下表的元素。\n\n在仔细查看程序过后，并没有发现上面的错误，我陷入了沉思。。。沉思过后终于发现问题所在：这是一个**线程安全**的问题！由于多线程之间用到了共享变量，同时读写却没有加锁，导致最后问题的产生。\n\n## 项目内容\n这个项目的大概内容是：与公安对接数据，主要是把机器人身上实时采集的数据实时的发送给公安那边的服务器，包括人脸图片、机器人状态、环境温湿度等... 由于需要在机器人内部传递数据并做处理再转发，这里用到了异步的*“订阅--发布”*模型。所有的发布者往**消息总线**上的话题发布消息，订阅者订阅需要的话题，以此来获取消息。\n\n具体的流程图如下：\n![订阅和发布](https://blog-pics.nos-eastchina1.126.net/pthreadThoughts/SUB-PUB.png)\n\n上面说到的每一个模块，上传人脸图片、机器人状态等，每个都是一个线程在工作。该线程首先订阅各自的话题，获取到要发送的信息内容，然后处理成json的可发送格式，再通过http协议发送过去。\n\n## 分析\n过程不难，但问题往往出现在看似简单的地方。就是由于我在多个线程中使用了同一个**共享的全局变量**，而且都对此变量进行了**写操作**，这些线程中都还**没加锁**，这就导致了错误的产生。\n\n我猜是因为在一个线程刚把共享资源读取出来，还没有使用，另一个线程开始就把共享资源的内容改了，这样就可能导致资源的混乱？\n\n## 线程同步的方法\n### rwlock\n\n### mutex\n\n","source":"_posts/pthreadThoughts.md","raw":"---\ntitle: 再谈线程安全\ndate: 2019-07-29 21:55:23\ntags:\n---\n\n## 背景\n今天在工作中，遇到了很恼人的错误`“double free or corruption”`，随着程序运行着，不一定何时就会出现，就像一颗定时炸弹，好气呀。网上找说是原因可能有两种：\n<!-- more -->\n> 1. 字面意思，释放两次。不过这种错误太过低级，一般都不会犯；\n> 2. 内存越界也会报这个错误。比如访问了超过数组下表的元素。\n\n在仔细查看程序过后，并没有发现上面的错误，我陷入了沉思。。。沉思过后终于发现问题所在：这是一个**线程安全**的问题！由于多线程之间用到了共享变量，同时读写却没有加锁，导致最后问题的产生。\n\n## 项目内容\n这个项目的大概内容是：与公安对接数据，主要是把机器人身上实时采集的数据实时的发送给公安那边的服务器，包括人脸图片、机器人状态、环境温湿度等... 由于需要在机器人内部传递数据并做处理再转发，这里用到了异步的*“订阅--发布”*模型。所有的发布者往**消息总线**上的话题发布消息，订阅者订阅需要的话题，以此来获取消息。\n\n具体的流程图如下：\n![订阅和发布](https://blog-pics.nos-eastchina1.126.net/pthreadThoughts/SUB-PUB.png)\n\n上面说到的每一个模块，上传人脸图片、机器人状态等，每个都是一个线程在工作。该线程首先订阅各自的话题，获取到要发送的信息内容，然后处理成json的可发送格式，再通过http协议发送过去。\n\n## 分析\n过程不难，但问题往往出现在看似简单的地方。就是由于我在多个线程中使用了同一个**共享的全局变量**，而且都对此变量进行了**写操作**，这些线程中都还**没加锁**，这就导致了错误的产生。\n\n我猜是因为在一个线程刚把共享资源读取出来，还没有使用，另一个线程开始就把共享资源的内容改了，这样就可能导致资源的混乱？\n\n## 线程同步的方法\n### rwlock\n\n### mutex\n\n","slug":"pthreadThoughts","published":1,"updated":"2019-09-10T15:29:58.798Z","_id":"cjyoig8iy0006pq0j32wfbi6i","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>今天在工作中，遇到了很恼人的错误<code>“double free or corruption”</code>，随着程序运行着，不一定何时就会出现，就像一颗定时炸弹，好气呀。网上找说是原因可能有两种：<br><a id=\"more\"></a></p>\n<blockquote>\n<ol>\n<li>字面意思，释放两次。不过这种错误太过低级，一般都不会犯；</li>\n<li>内存越界也会报这个错误。比如访问了超过数组下表的元素。</li>\n</ol>\n</blockquote>\n<p>在仔细查看程序过后，并没有发现上面的错误，我陷入了沉思。。。沉思过后终于发现问题所在：这是一个<strong>线程安全</strong>的问题！由于多线程之间用到了共享变量，同时读写却没有加锁，导致最后问题的产生。</p>\n<h2 id=\"项目内容\"><a href=\"#项目内容\" class=\"headerlink\" title=\"项目内容\"></a>项目内容</h2><p>这个项目的大概内容是：与公安对接数据，主要是把机器人身上实时采集的数据实时的发送给公安那边的服务器，包括人脸图片、机器人状态、环境温湿度等… 由于需要在机器人内部传递数据并做处理再转发，这里用到了异步的<em>“订阅–发布”</em>模型。所有的发布者往<strong>消息总线</strong>上的话题发布消息，订阅者订阅需要的话题，以此来获取消息。</p>\n<p>具体的流程图如下：<br><img src=\"https://blog-pics.nos-eastchina1.126.net/pthreadThoughts/SUB-PUB.png\" alt=\"订阅和发布\"></p>\n<p>上面说到的每一个模块，上传人脸图片、机器人状态等，每个都是一个线程在工作。该线程首先订阅各自的话题，获取到要发送的信息内容，然后处理成json的可发送格式，再通过http协议发送过去。</p>\n<h2 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h2><p>过程不难，但问题往往出现在看似简单的地方。就是由于我在多个线程中使用了同一个<strong>共享的全局变量</strong>，而且都对此变量进行了<strong>写操作</strong>，这些线程中都还<strong>没加锁</strong>，这就导致了错误的产生。</p>\n<p>我猜是因为在一个线程刚把共享资源读取出来，还没有使用，另一个线程开始就把共享资源的内容改了，这样就可能导致资源的混乱？</p>\n<h2 id=\"线程同步的方法\"><a href=\"#线程同步的方法\" class=\"headerlink\" title=\"线程同步的方法\"></a>线程同步的方法</h2><h3 id=\"rwlock\"><a href=\"#rwlock\" class=\"headerlink\" title=\"rwlock\"></a>rwlock</h3><h3 id=\"mutex\"><a href=\"#mutex\" class=\"headerlink\" title=\"mutex\"></a>mutex</h3>","site":{"data":{}},"excerpt":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>今天在工作中，遇到了很恼人的错误<code>“double free or corruption”</code>，随着程序运行着，不一定何时就会出现，就像一颗定时炸弹，好气呀。网上找说是原因可能有两种：<br></p>","more":"<p></p>\n<blockquote>\n<ol>\n<li>字面意思，释放两次。不过这种错误太过低级，一般都不会犯；</li>\n<li>内存越界也会报这个错误。比如访问了超过数组下表的元素。</li>\n</ol>\n</blockquote>\n<p>在仔细查看程序过后，并没有发现上面的错误，我陷入了沉思。。。沉思过后终于发现问题所在：这是一个<strong>线程安全</strong>的问题！由于多线程之间用到了共享变量，同时读写却没有加锁，导致最后问题的产生。</p>\n<h2 id=\"项目内容\"><a href=\"#项目内容\" class=\"headerlink\" title=\"项目内容\"></a>项目内容</h2><p>这个项目的大概内容是：与公安对接数据，主要是把机器人身上实时采集的数据实时的发送给公安那边的服务器，包括人脸图片、机器人状态、环境温湿度等… 由于需要在机器人内部传递数据并做处理再转发，这里用到了异步的<em>“订阅–发布”</em>模型。所有的发布者往<strong>消息总线</strong>上的话题发布消息，订阅者订阅需要的话题，以此来获取消息。</p>\n<p>具体的流程图如下：<br><img src=\"https://blog-pics.nos-eastchina1.126.net/pthreadThoughts/SUB-PUB.png\" alt=\"订阅和发布\"></p>\n<p>上面说到的每一个模块，上传人脸图片、机器人状态等，每个都是一个线程在工作。该线程首先订阅各自的话题，获取到要发送的信息内容，然后处理成json的可发送格式，再通过http协议发送过去。</p>\n<h2 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h2><p>过程不难，但问题往往出现在看似简单的地方。就是由于我在多个线程中使用了同一个<strong>共享的全局变量</strong>，而且都对此变量进行了<strong>写操作</strong>，这些线程中都还<strong>没加锁</strong>，这就导致了错误的产生。</p>\n<p>我猜是因为在一个线程刚把共享资源读取出来，还没有使用，另一个线程开始就把共享资源的内容改了，这样就可能导致资源的混乱？</p>\n<h2 id=\"线程同步的方法\"><a href=\"#线程同步的方法\" class=\"headerlink\" title=\"线程同步的方法\"></a>线程同步的方法</h2><h3 id=\"rwlock\"><a href=\"#rwlock\" class=\"headerlink\" title=\"rwlock\"></a>rwlock</h3><h3 id=\"mutex\"><a href=\"#mutex\" class=\"headerlink\" title=\"mutex\"></a>mutex</h3>"},{"title":"重新思考内存申请","date":"2019-03-15T06:48:59.000Z","_content":"## 前言\n最近在一个项目中用C语言做一个restful服务的桥接器，具体功能就是把Java端发过来的请求报文解析，再用解析出的内容调用C底层相应的接口，最后把C接口返回的信息再发给Java端。\n测试时发现，多数接口的请求能正常接收到返回信息，但某些请求报文特别长的接口，就无法正常获取返回报文。查了代码发现是**接收报文变量**的长度定义过短导致程序提前退出了。我便把**接收报文的变量**变为了动态申请内存，申请了1MB的内存，结尾处再释放掉，这样改过之后，程序没有提前退出，却出现了段错误。查了半天，最后发现问题出在一个调试语句上，那里还是用的**栈内存**申请，在把最大报文长度限制变成1MB之后，加上调用底层C接口中申请的**栈地址空间**,超过了linux栈空间的限制，导致**内存溢出**了。\n<!-- more -->\n借此机会详细的回顾一下linux下的内存申请相关的内容。\n\n## 栈内存申请\n这是系统分配内存的方式，也是最基本的一种内存申请方式，如要申请**十个字节**的空间，并全部赋值为尾零：\n``` C\nchar str[10] = {0};\n```\n这样就在栈上申请到了**10个字节**的空间，这一部分空间是无需程序员手动释放的，在程序执行结束或一个代码块结束后会由操作系统自动收回。其操作方式类似于数据结构的**栈**，只要栈剩余的空间大于所申请的空间，系统将为程序提供内存，否则将报异常提示栈溢出。\n在linux系统下，查看系统栈的空间容量可以用`ulimit -a`或`limit`直接查看：\n\n| ![ulimit -a](https://blog-pics.nos-eastchina1.126.net/rethinkOfMelloc/ulimit%20-a%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C.jpg) |  ![limit](https://blog-pics.nos-eastchina1.126.net/rethinkOfMelloc/limit%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C.jpg)| \n| --- | --- |\n\n可以看到，在mac系统下，**stacksize**的大小是8MB，即8 \\* 1024 \\* 1024个字节\n所以，这样最多申请的占内存空间为：`char str[8192 * 1024]`，超过这个数字就会报段错误，也就是由栈内存溢出导致的。\n测试一下，\n``` C\n#define MAXLEN 8192 * 1023 \n\nint main() {\n    char str[MAXLEN];\n    return 0;\n}\n```\n当把**MAXLEN**赋值为8192 \\* 1023时，程序还能正常运行，但改为8192 \\* 1024时就**段错误**了，可能包含几KB的栈信息数据。由此证明了栈空间确实是8MB（软限制），可以通过`ulimit -s`命令临时改变栈空间的大小，突破软限制。\n\n## 堆内存申请\n一般由程序员分配和释放，程序员若不释放，程序结束时可能由OS回收。但它与数据结构的堆是两码事，分配方式类似于数据结构的**链表**。\n申请一个10字节的空间书写如下：\n``` C\nchar *str = (char *)malloc(10);\n```\n或\n``` C\nchar *str = (char *)calloc(1, 10);\n```\n在堆上的内存申请，默认是没有**软限制**的，只依赖系统**硬限制**，故在申请**大空间**时需要用**动态申请**的方法，不过需要注意的是在用完该内存后要及时释放，否则会导致内存泄露而使内存耗尽。下面就来说一下内存释放的方法。\n\n## 内存释放\n堆上内存需要手动释放，方法如下：\n``` C\nif (str)\n    free(str);\nstr = NULL;\n```\n一般习惯用宏来实现：\n``` C\n#define dataFree(str) if(str){free(str);str=NULL;}\n```\n最后把`str`指针指向`NULL`的原因是，`free`操作仅释放了`str`指向的内存空间，而不包括`str`指针本身，`str`仍旧指向那片内存地址，只不过是未申请的了，如果后面的程序又有操作到了`str`指针，将会产生不可预知的错误，故要将其指向`NULL`。\n\n## 总结\n常常说，细节决定成败。这次犯的错误不是什么大错误，不过却造成了整个桥接器无法使用。在考虑问题的时候一定要周全，不但要保证自己写的模块没有问题，还要考虑到模块与模块之间交互的过程中可能会出现哪些问题。就像这次的内存溢出，自己这里申请1MB是没问题的，但加上其他模块的就超出了系统最大限制了，当然别人的模块也要改，但自己这里一定要足够健壮。\n","source":"_posts/rethinkOfMelloc.md","raw":"---\ntitle: 重新思考内存申请\ndate: 2019-03-15 14:48:59\ntags: 动态内存/栈/堆\ncategories: \n- 工作\n---\n## 前言\n最近在一个项目中用C语言做一个restful服务的桥接器，具体功能就是把Java端发过来的请求报文解析，再用解析出的内容调用C底层相应的接口，最后把C接口返回的信息再发给Java端。\n测试时发现，多数接口的请求能正常接收到返回信息，但某些请求报文特别长的接口，就无法正常获取返回报文。查了代码发现是**接收报文变量**的长度定义过短导致程序提前退出了。我便把**接收报文的变量**变为了动态申请内存，申请了1MB的内存，结尾处再释放掉，这样改过之后，程序没有提前退出，却出现了段错误。查了半天，最后发现问题出在一个调试语句上，那里还是用的**栈内存**申请，在把最大报文长度限制变成1MB之后，加上调用底层C接口中申请的**栈地址空间**,超过了linux栈空间的限制，导致**内存溢出**了。\n<!-- more -->\n借此机会详细的回顾一下linux下的内存申请相关的内容。\n\n## 栈内存申请\n这是系统分配内存的方式，也是最基本的一种内存申请方式，如要申请**十个字节**的空间，并全部赋值为尾零：\n``` C\nchar str[10] = {0};\n```\n这样就在栈上申请到了**10个字节**的空间，这一部分空间是无需程序员手动释放的，在程序执行结束或一个代码块结束后会由操作系统自动收回。其操作方式类似于数据结构的**栈**，只要栈剩余的空间大于所申请的空间，系统将为程序提供内存，否则将报异常提示栈溢出。\n在linux系统下，查看系统栈的空间容量可以用`ulimit -a`或`limit`直接查看：\n\n| ![ulimit -a](https://blog-pics.nos-eastchina1.126.net/rethinkOfMelloc/ulimit%20-a%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C.jpg) |  ![limit](https://blog-pics.nos-eastchina1.126.net/rethinkOfMelloc/limit%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C.jpg)| \n| --- | --- |\n\n可以看到，在mac系统下，**stacksize**的大小是8MB，即8 \\* 1024 \\* 1024个字节\n所以，这样最多申请的占内存空间为：`char str[8192 * 1024]`，超过这个数字就会报段错误，也就是由栈内存溢出导致的。\n测试一下，\n``` C\n#define MAXLEN 8192 * 1023 \n\nint main() {\n    char str[MAXLEN];\n    return 0;\n}\n```\n当把**MAXLEN**赋值为8192 \\* 1023时，程序还能正常运行，但改为8192 \\* 1024时就**段错误**了，可能包含几KB的栈信息数据。由此证明了栈空间确实是8MB（软限制），可以通过`ulimit -s`命令临时改变栈空间的大小，突破软限制。\n\n## 堆内存申请\n一般由程序员分配和释放，程序员若不释放，程序结束时可能由OS回收。但它与数据结构的堆是两码事，分配方式类似于数据结构的**链表**。\n申请一个10字节的空间书写如下：\n``` C\nchar *str = (char *)malloc(10);\n```\n或\n``` C\nchar *str = (char *)calloc(1, 10);\n```\n在堆上的内存申请，默认是没有**软限制**的，只依赖系统**硬限制**，故在申请**大空间**时需要用**动态申请**的方法，不过需要注意的是在用完该内存后要及时释放，否则会导致内存泄露而使内存耗尽。下面就来说一下内存释放的方法。\n\n## 内存释放\n堆上内存需要手动释放，方法如下：\n``` C\nif (str)\n    free(str);\nstr = NULL;\n```\n一般习惯用宏来实现：\n``` C\n#define dataFree(str) if(str){free(str);str=NULL;}\n```\n最后把`str`指针指向`NULL`的原因是，`free`操作仅释放了`str`指向的内存空间，而不包括`str`指针本身，`str`仍旧指向那片内存地址，只不过是未申请的了，如果后面的程序又有操作到了`str`指针，将会产生不可预知的错误，故要将其指向`NULL`。\n\n## 总结\n常常说，细节决定成败。这次犯的错误不是什么大错误，不过却造成了整个桥接器无法使用。在考虑问题的时候一定要周全，不但要保证自己写的模块没有问题，还要考虑到模块与模块之间交互的过程中可能会出现哪些问题。就像这次的内存溢出，自己这里申请1MB是没问题的，但加上其他模块的就超出了系统最大限制了，当然别人的模块也要改，但自己这里一定要足够健壮。\n","slug":"rethinkOfMelloc","published":1,"updated":"2019-04-13T08:08:30.539Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyoig8iz0009pq0jlbq2512k","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>最近在一个项目中用C语言做一个restful服务的桥接器，具体功能就是把Java端发过来的请求报文解析，再用解析出的内容调用C底层相应的接口，最后把C接口返回的信息再发给Java端。<br>测试时发现，多数接口的请求能正常接收到返回信息，但某些请求报文特别长的接口，就无法正常获取返回报文。查了代码发现是<strong>接收报文变量</strong>的长度定义过短导致程序提前退出了。我便把<strong>接收报文的变量</strong>变为了动态申请内存，申请了1MB的内存，结尾处再释放掉，这样改过之后，程序没有提前退出，却出现了段错误。查了半天，最后发现问题出在一个调试语句上，那里还是用的<strong>栈内存</strong>申请，在把最大报文长度限制变成1MB之后，加上调用底层C接口中申请的<strong>栈地址空间</strong>,超过了linux栈空间的限制，导致<strong>内存溢出</strong>了。<br><a id=\"more\"></a><br>借此机会详细的回顾一下linux下的内存申请相关的内容。</p>\n<h2 id=\"栈内存申请\"><a href=\"#栈内存申请\" class=\"headerlink\" title=\"栈内存申请\"></a>栈内存申请</h2><p>这是系统分配内存的方式，也是最基本的一种内存申请方式，如要申请<strong>十个字节</strong>的空间，并全部赋值为尾零：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> str[<span class=\"number\">10</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>这样就在栈上申请到了<strong>10个字节</strong>的空间，这一部分空间是无需程序员手动释放的，在程序执行结束或一个代码块结束后会由操作系统自动收回。其操作方式类似于数据结构的<strong>栈</strong>，只要栈剩余的空间大于所申请的空间，系统将为程序提供内存，否则将报异常提示栈溢出。<br>在linux系统下，查看系统栈的空间容量可以用<code>ulimit -a</code>或<code>limit</code>直接查看：</p>\n<table>\n<thead>\n<tr>\n<th><img src=\"https://blog-pics.nos-eastchina1.126.net/rethinkOfMelloc/ulimit%20-a%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C.jpg\" alt=\"ulimit -a\"></th>\n<th><img src=\"https://blog-pics.nos-eastchina1.126.net/rethinkOfMelloc/limit%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C.jpg\" alt=\"limit\"></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>可以看到，在mac系统下，<strong>stacksize</strong>的大小是8MB，即8 * 1024 * 1024个字节<br>所以，这样最多申请的占内存空间为：<code>char str[8192 * 1024]</code>，超过这个数字就会报段错误，也就是由栈内存溢出导致的。<br>测试一下，<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXLEN 8192 * 1023 </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> str[MAXLEN];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当把<strong>MAXLEN</strong>赋值为8192 * 1023时，程序还能正常运行，但改为8192 * 1024时就<strong>段错误</strong>了，可能包含几KB的栈信息数据。由此证明了栈空间确实是8MB（软限制），可以通过<code>ulimit -s</code>命令临时改变栈空间的大小，突破软限制。</p>\n<h2 id=\"堆内存申请\"><a href=\"#堆内存申请\" class=\"headerlink\" title=\"堆内存申请\"></a>堆内存申请</h2><p>一般由程序员分配和释放，程序员若不释放，程序结束时可能由OS回收。但它与数据结构的堆是两码事，分配方式类似于数据结构的<strong>链表</strong>。<br>申请一个10字节的空间书写如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> *str = (<span class=\"keyword\">char</span> *)<span class=\"built_in\">malloc</span>(<span class=\"number\">10</span>);</span><br></pre></td></tr></table></figure></p>\n<p>或<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> *str = (<span class=\"keyword\">char</span> *)<span class=\"built_in\">calloc</span>(<span class=\"number\">1</span>, <span class=\"number\">10</span>);</span><br></pre></td></tr></table></figure></p>\n<p>在堆上的内存申请，默认是没有<strong>软限制</strong>的，只依赖系统<strong>硬限制</strong>，故在申请<strong>大空间</strong>时需要用<strong>动态申请</strong>的方法，不过需要注意的是在用完该内存后要及时释放，否则会导致内存泄露而使内存耗尽。下面就来说一下内存释放的方法。</p>\n<h2 id=\"内存释放\"><a href=\"#内存释放\" class=\"headerlink\" title=\"内存释放\"></a>内存释放</h2><p>堆上内存需要手动释放，方法如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (str)</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(str);</span><br><span class=\"line\">str = <span class=\"literal\">NULL</span>;</span><br></pre></td></tr></table></figure></p>\n<p>一般习惯用宏来实现：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> dataFree(str) <span class=\"meta-keyword\">if</span>(str)&#123;free(str);str=NULL;&#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>最后把<code>str</code>指针指向<code>NULL</code>的原因是，<code>free</code>操作仅释放了<code>str</code>指向的内存空间，而不包括<code>str</code>指针本身，<code>str</code>仍旧指向那片内存地址，只不过是未申请的了，如果后面的程序又有操作到了<code>str</code>指针，将会产生不可预知的错误，故要将其指向<code>NULL</code>。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>常常说，细节决定成败。这次犯的错误不是什么大错误，不过却造成了整个桥接器无法使用。在考虑问题的时候一定要周全，不但要保证自己写的模块没有问题，还要考虑到模块与模块之间交互的过程中可能会出现哪些问题。就像这次的内存溢出，自己这里申请1MB是没问题的，但加上其他模块的就超出了系统最大限制了，当然别人的模块也要改，但自己这里一定要足够健壮。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>最近在一个项目中用C语言做一个restful服务的桥接器，具体功能就是把Java端发过来的请求报文解析，再用解析出的内容调用C底层相应的接口，最后把C接口返回的信息再发给Java端。<br>测试时发现，多数接口的请求能正常接收到返回信息，但某些请求报文特别长的接口，就无法正常获取返回报文。查了代码发现是<strong>接收报文变量</strong>的长度定义过短导致程序提前退出了。我便把<strong>接收报文的变量</strong>变为了动态申请内存，申请了1MB的内存，结尾处再释放掉，这样改过之后，程序没有提前退出，却出现了段错误。查了半天，最后发现问题出在一个调试语句上，那里还是用的<strong>栈内存</strong>申请，在把最大报文长度限制变成1MB之后，加上调用底层C接口中申请的<strong>栈地址空间</strong>,超过了linux栈空间的限制，导致<strong>内存溢出</strong>了。<br></p>","more":"<br>借此机会详细的回顾一下linux下的内存申请相关的内容。<p></p>\n<h2 id=\"栈内存申请\"><a href=\"#栈内存申请\" class=\"headerlink\" title=\"栈内存申请\"></a>栈内存申请</h2><p>这是系统分配内存的方式，也是最基本的一种内存申请方式，如要申请<strong>十个字节</strong>的空间，并全部赋值为尾零：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> str[<span class=\"number\">10</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>这样就在栈上申请到了<strong>10个字节</strong>的空间，这一部分空间是无需程序员手动释放的，在程序执行结束或一个代码块结束后会由操作系统自动收回。其操作方式类似于数据结构的<strong>栈</strong>，只要栈剩余的空间大于所申请的空间，系统将为程序提供内存，否则将报异常提示栈溢出。<br>在linux系统下，查看系统栈的空间容量可以用<code>ulimit -a</code>或<code>limit</code>直接查看：</p>\n<table>\n<thead>\n<tr>\n<th><img src=\"https://blog-pics.nos-eastchina1.126.net/rethinkOfMelloc/ulimit%20-a%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C.jpg\" alt=\"ulimit -a\"></th>\n<th><img src=\"https://blog-pics.nos-eastchina1.126.net/rethinkOfMelloc/limit%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C.jpg\" alt=\"limit\"></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>可以看到，在mac系统下，<strong>stacksize</strong>的大小是8MB，即8 * 1024 * 1024个字节<br>所以，这样最多申请的占内存空间为：<code>char str[8192 * 1024]</code>，超过这个数字就会报段错误，也就是由栈内存溢出导致的。<br>测试一下，<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXLEN 8192 * 1023 </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> str[MAXLEN];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当把<strong>MAXLEN</strong>赋值为8192 * 1023时，程序还能正常运行，但改为8192 * 1024时就<strong>段错误</strong>了，可能包含几KB的栈信息数据。由此证明了栈空间确实是8MB（软限制），可以通过<code>ulimit -s</code>命令临时改变栈空间的大小，突破软限制。</p>\n<h2 id=\"堆内存申请\"><a href=\"#堆内存申请\" class=\"headerlink\" title=\"堆内存申请\"></a>堆内存申请</h2><p>一般由程序员分配和释放，程序员若不释放，程序结束时可能由OS回收。但它与数据结构的堆是两码事，分配方式类似于数据结构的<strong>链表</strong>。<br>申请一个10字节的空间书写如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> *str = (<span class=\"keyword\">char</span> *)<span class=\"built_in\">malloc</span>(<span class=\"number\">10</span>);</span><br></pre></td></tr></table></figure></p>\n<p>或<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> *str = (<span class=\"keyword\">char</span> *)<span class=\"built_in\">calloc</span>(<span class=\"number\">1</span>, <span class=\"number\">10</span>);</span><br></pre></td></tr></table></figure></p>\n<p>在堆上的内存申请，默认是没有<strong>软限制</strong>的，只依赖系统<strong>硬限制</strong>，故在申请<strong>大空间</strong>时需要用<strong>动态申请</strong>的方法，不过需要注意的是在用完该内存后要及时释放，否则会导致内存泄露而使内存耗尽。下面就来说一下内存释放的方法。</p>\n<h2 id=\"内存释放\"><a href=\"#内存释放\" class=\"headerlink\" title=\"内存释放\"></a>内存释放</h2><p>堆上内存需要手动释放，方法如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (str)</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(str);</span><br><span class=\"line\">str = <span class=\"literal\">NULL</span>;</span><br></pre></td></tr></table></figure></p>\n<p>一般习惯用宏来实现：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> dataFree(str) <span class=\"meta-keyword\">if</span>(str)&#123;free(str);str=NULL;&#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>最后把<code>str</code>指针指向<code>NULL</code>的原因是，<code>free</code>操作仅释放了<code>str</code>指向的内存空间，而不包括<code>str</code>指针本身，<code>str</code>仍旧指向那片内存地址，只不过是未申请的了，如果后面的程序又有操作到了<code>str</code>指针，将会产生不可预知的错误，故要将其指向<code>NULL</code>。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>常常说，细节决定成败。这次犯的错误不是什么大错误，不过却造成了整个桥接器无法使用。在考虑问题的时候一定要周全，不但要保证自己写的模块没有问题，还要考虑到模块与模块之间交互的过程中可能会出现哪些问题。就像这次的内存溢出，自己这里申请1MB是没问题的，但加上其他模块的就超出了系统最大限制了，当然别人的模块也要改，但自己这里一定要足够健壮。</p>"},{"title":"你想要了解的单链表","date":"2018-10-31T08:30:52.000Z","_content":"\n## 为什么要说链表\n链表这个词想必大家都很熟悉，但在实际工作中，我发现虽然经常会用到，但如果真是让自己从头开始造轮子，真正的从零开发，却还是会有种无从下手的感觉。如果你和我一样，请继续看下去。\n<!-- more -->\n本文主要会讲链表的创建，销毁和遍历等链表的基本操作，并以几道面试题为例来做更具体的说明。\n## 开始创建链表\n关于链表和数组的区别与各自的优缺点在此就不细说了，随便网上一抓一大把，今天主要弄些实在的，下面先从如何创建一个链表开始。\n链表说白了就是从一个头指针开始，依次往后顺延连接的一个指针链。所以想获取一个链表只需要知道它的头指针即可，下面的是创建一个链表的代码。\n``` C\ntypedef struct ListNode {\n    int m_value;\n    ListNode *p_next;\n    ListNode(int x): m_value(x), p_next(NULL) { }\n}Link;\n\n/* 根据n个元素的数组arr创建一个链表，并返回链表头 */\nLink *createALinklist(int arr[], int n)\n{\n    if (n <= 0)\n        return NULL;\n    Link *head = new Link(arr[0]);\n    Link *cur_node = head;\n    for (int i = 1; i < n; ++i)\n    {\n        cur_node->p_next = new Link(arr[i]);\n        cur_node = cur_node->p_next;\n    }\n    return head;\n}\n```\n## 遍历链表\n知道了头指针，很方便地就可以遍历整个链表内容；\n``` C\n/* 打印以head为头的链表节点信息 */\nvoid traverseList(Link *head)\n{\n    if (head == NULL)\n        return;\n    else\n    {\n        Link *cur_node = head;\n        for (; cur_node != NULL; cur_node = cur_node->p_next)\n            cout << cur_node->m_value << \" \";\n        cout << endl;\n    }\n}\n```\n## 销毁链表内容\n在释放链表空间时要注意一个顺序问题，因为如果释放操作在指针指向下一个节点之前，那么就无法找到接下来的节点；故为了保证能正确释放，需要用到一个新指针，保存当前节点的位置。\n``` C\n/* 销毁以head为头的链表空间 */\nvoid destoryALinklist(Link *head)\n{\n    if (head == NULL)\n        return;\n    Link *cur_node = head;\n    while (cur_node != NULL)\n    {\n        Link *delNode = cur_node;\n        cur_node = cur_node->p_next;  // 要注意删除前要先将当前节点指针指向下一个位置\n        delete delNode;\n    }\n    return;\n}\n```\n## 添加链表节点\n在链表的结尾添加一个新节点，这也属于链表的基本操作之一。\n但需要注意的是：\n* 链表为空时，要直接把头节点指向新节点；\n* 要想在函数内部改变指针本身，需要用到二级指针\n\n``` C\n/* 在链表结尾添加一个节点 */\nbool addOneNodeToTail(int item, Link **head)  // **是为了要改变head指向的地址\n{\n    Link *cur = *head;\n    Link *pnew = new Link(item);\n    if (pnew == NULL)  // 内存申请失败\n        return false;\n\n    if (cur == NULL)  // 链表为空时\n        *head = pnew;\n    else\n    {\n        while (cur->p_next != NULL)\n            cur = cur->p_next;\n        cur->p_next = pnew;\n    }\n    return true;\n\n}\n```\n## 面试题：删除链表节点\n![面试题13](https://blog-pics.nos-eastchina1.126.net/jianzhioffer13.png)\n### 常规删除节点的方法\n要想删除链表的一个节点，首先要遍历找到前一个节点的位置，然后再删除该节点；\n如有链表`a--b--c--d--null`，要删除c节点，则需要遍历到c的前一个节点b，把b的next指针指向d，再释放c，即完成了删除操作；\n但这样有n个节点的时间复杂度是O(n)，不符合题目的要求；\n### 符合题目要求的方法\n如想删除c节点，不一定要遍历到其前一个节点b，有了c节点的指针，可以很方便地获取到其下一个节点d，而删除操作就相当于是：\n* 把d节点的内容赋给c节点\n* 把c节点的next指针指向d的next\n\n以上操作就无需遍历到c的上一个节点，此操作的时间复杂度是O(1)，符合题目的要求；\n但需要注意两种特殊情况：\n1. 链表只有一个节点，此时操作就变成了把头节点置null，并释放空间；\n2. 要删除节点是链表的最后一个节点，由于没有后一个节点，此时需用常规删除节点的方法进行删除；\n\n代码如下：\n``` C\n/* 删除指针指向的链表节点 */\nbool deleteOneNode(Link *head, Link *toBeDeleted)\n{\n    if (!head || !toBeDeleted)\n        return false;\n    // 链表只有一个节点\n    if (head->p_next == NULL)\n    {\n        delete toBeDeleted;\n        toBeDeleted = NULL;\n        head = NULL;\n    }\n    // 要删除的节点是尾节点\n    else if (toBeDeleted->p_next == NULL)\n    {\n        Link *cur_node = head;\n        while (cur_node != NULL)\n        {\n            if (cur_node->p_next != toBeDeleted)\n                cur_node = cur_node->p_next;\n            else\n            {\n                cur_node ->p_next = NULL;\n                delete toBeDeleted;\n                toBeDeleted = NULL;\n            }\n        }\n    }\n    else\n    {\n        // 删除中间的节点\n        toBeDeleted->m_value = toBeDeleted->p_next->m_value;\n        toBeDeleted->p_next = toBeDeleted->p_next->p_next;\n        delete toBeDeleted->p_next;\n    }\n    return true;\n}\n```\n测试程序\n``` C\nint main()\n{\n    int arr[] = {1,2,3,4,5};\n    Link *head = createALinklist(arr, 5);\n    Link *del_node = head;\n    traverseList(head);\n    for (int i = 0; i < 3; ++i)\n    {\n        del_node = del_node->p_next;\n    }\n    deleteOneNode(head, del_node);\n    traverseList(head);\n    destoryALinklist(head);\n\n    return 0;\n}\n```\n输出结果\n![运行结果](https://blog-pics.nos-eastchina1.126.net/result.png)\n\n## 面试题：反转链表\n![面试题16](https://blog-pics.nos-eastchina1.126.net/jianzhioffer16.jpg)\n### 反转链表的方法\n很简单，把后一个节点的next指针指向前一个节点就好了；\n但是需要注意：\n* 反转之后头节点成为尾节点，后面是`NULL`；\n* 容易出现链表的断裂；\n* 当链表为空时，要做健壮性处理。\n\n综上，为了链表不断裂，需要三个指针来做这件事，一个指向当前节点，一个是它的上一节点，一个是下个节点，即`cur，pre，next`。我们有了这三个指针，接下来的事就好办了，只需从头遍历链表，把每个节点的next指向pre即可。\n代码如下：\n``` C\nLink *reverseList(Link *head)\n{\n    // first input check\n    if (head == NULL)\n        return NULL;\n\n    Link *cur = head;  // 当前节点指针\n    Link *next;        // 下一个节点指针\n    Link *pre = NULL;  // 前一个节点指针\n\n    while (cur != NULL)\n    {\n        if (cur->p_next == NULL)  // 到了尾节点\n        {\n            cur->p_next = pre;\n            break;\n        }\n        next = cur->p_next;\n        cur->p_next = pre;\n        pre = cur;\n        cur = next;\n    }\n    return cur;\n}\n```\n测试程序代码：\n``` C\nint main()\n{\n    int arr[5] = {1,2,3,4,5};\n    Link *head = createALinklist(arr, 5);\n    cout << \"before reverse:\" << endl;\n    traverseList(head);\n    Link *rhead = reverseList(head);\n    cout << \"after reverse:\" << endl;\n    traverseList(rhead);\n\n    return 0;\n}\n```\n运行结果：\n![反转链表运行结果](https://blog-pics.nos-eastchina1.126.net/result16.jpg)\n当问题不好解决时，不妨多用几个指针，也许就能豁然开朗。\n\n## 总结\n这些只是单链表最基础最简单的一些操作，实际工作中的链表应用会更复杂。不过只有把最基础的东西掌握好，才能向更强的地方迈进。\n还有一些如双向链表，循环链表等可能会在后续的学习中讲到。\n\n","source":"_posts/single-linklist.md","raw":"---\ntitle: 你想要了解的单链表\ndate: 2018-10-31 16:30:52\ntags: \n- 算法\n- 数据结构\n- 单链表\ncategories:\n- Data Structure\n---\n\n## 为什么要说链表\n链表这个词想必大家都很熟悉，但在实际工作中，我发现虽然经常会用到，但如果真是让自己从头开始造轮子，真正的从零开发，却还是会有种无从下手的感觉。如果你和我一样，请继续看下去。\n<!-- more -->\n本文主要会讲链表的创建，销毁和遍历等链表的基本操作，并以几道面试题为例来做更具体的说明。\n## 开始创建链表\n关于链表和数组的区别与各自的优缺点在此就不细说了，随便网上一抓一大把，今天主要弄些实在的，下面先从如何创建一个链表开始。\n链表说白了就是从一个头指针开始，依次往后顺延连接的一个指针链。所以想获取一个链表只需要知道它的头指针即可，下面的是创建一个链表的代码。\n``` C\ntypedef struct ListNode {\n    int m_value;\n    ListNode *p_next;\n    ListNode(int x): m_value(x), p_next(NULL) { }\n}Link;\n\n/* 根据n个元素的数组arr创建一个链表，并返回链表头 */\nLink *createALinklist(int arr[], int n)\n{\n    if (n <= 0)\n        return NULL;\n    Link *head = new Link(arr[0]);\n    Link *cur_node = head;\n    for (int i = 1; i < n; ++i)\n    {\n        cur_node->p_next = new Link(arr[i]);\n        cur_node = cur_node->p_next;\n    }\n    return head;\n}\n```\n## 遍历链表\n知道了头指针，很方便地就可以遍历整个链表内容；\n``` C\n/* 打印以head为头的链表节点信息 */\nvoid traverseList(Link *head)\n{\n    if (head == NULL)\n        return;\n    else\n    {\n        Link *cur_node = head;\n        for (; cur_node != NULL; cur_node = cur_node->p_next)\n            cout << cur_node->m_value << \" \";\n        cout << endl;\n    }\n}\n```\n## 销毁链表内容\n在释放链表空间时要注意一个顺序问题，因为如果释放操作在指针指向下一个节点之前，那么就无法找到接下来的节点；故为了保证能正确释放，需要用到一个新指针，保存当前节点的位置。\n``` C\n/* 销毁以head为头的链表空间 */\nvoid destoryALinklist(Link *head)\n{\n    if (head == NULL)\n        return;\n    Link *cur_node = head;\n    while (cur_node != NULL)\n    {\n        Link *delNode = cur_node;\n        cur_node = cur_node->p_next;  // 要注意删除前要先将当前节点指针指向下一个位置\n        delete delNode;\n    }\n    return;\n}\n```\n## 添加链表节点\n在链表的结尾添加一个新节点，这也属于链表的基本操作之一。\n但需要注意的是：\n* 链表为空时，要直接把头节点指向新节点；\n* 要想在函数内部改变指针本身，需要用到二级指针\n\n``` C\n/* 在链表结尾添加一个节点 */\nbool addOneNodeToTail(int item, Link **head)  // **是为了要改变head指向的地址\n{\n    Link *cur = *head;\n    Link *pnew = new Link(item);\n    if (pnew == NULL)  // 内存申请失败\n        return false;\n\n    if (cur == NULL)  // 链表为空时\n        *head = pnew;\n    else\n    {\n        while (cur->p_next != NULL)\n            cur = cur->p_next;\n        cur->p_next = pnew;\n    }\n    return true;\n\n}\n```\n## 面试题：删除链表节点\n![面试题13](https://blog-pics.nos-eastchina1.126.net/jianzhioffer13.png)\n### 常规删除节点的方法\n要想删除链表的一个节点，首先要遍历找到前一个节点的位置，然后再删除该节点；\n如有链表`a--b--c--d--null`，要删除c节点，则需要遍历到c的前一个节点b，把b的next指针指向d，再释放c，即完成了删除操作；\n但这样有n个节点的时间复杂度是O(n)，不符合题目的要求；\n### 符合题目要求的方法\n如想删除c节点，不一定要遍历到其前一个节点b，有了c节点的指针，可以很方便地获取到其下一个节点d，而删除操作就相当于是：\n* 把d节点的内容赋给c节点\n* 把c节点的next指针指向d的next\n\n以上操作就无需遍历到c的上一个节点，此操作的时间复杂度是O(1)，符合题目的要求；\n但需要注意两种特殊情况：\n1. 链表只有一个节点，此时操作就变成了把头节点置null，并释放空间；\n2. 要删除节点是链表的最后一个节点，由于没有后一个节点，此时需用常规删除节点的方法进行删除；\n\n代码如下：\n``` C\n/* 删除指针指向的链表节点 */\nbool deleteOneNode(Link *head, Link *toBeDeleted)\n{\n    if (!head || !toBeDeleted)\n        return false;\n    // 链表只有一个节点\n    if (head->p_next == NULL)\n    {\n        delete toBeDeleted;\n        toBeDeleted = NULL;\n        head = NULL;\n    }\n    // 要删除的节点是尾节点\n    else if (toBeDeleted->p_next == NULL)\n    {\n        Link *cur_node = head;\n        while (cur_node != NULL)\n        {\n            if (cur_node->p_next != toBeDeleted)\n                cur_node = cur_node->p_next;\n            else\n            {\n                cur_node ->p_next = NULL;\n                delete toBeDeleted;\n                toBeDeleted = NULL;\n            }\n        }\n    }\n    else\n    {\n        // 删除中间的节点\n        toBeDeleted->m_value = toBeDeleted->p_next->m_value;\n        toBeDeleted->p_next = toBeDeleted->p_next->p_next;\n        delete toBeDeleted->p_next;\n    }\n    return true;\n}\n```\n测试程序\n``` C\nint main()\n{\n    int arr[] = {1,2,3,4,5};\n    Link *head = createALinklist(arr, 5);\n    Link *del_node = head;\n    traverseList(head);\n    for (int i = 0; i < 3; ++i)\n    {\n        del_node = del_node->p_next;\n    }\n    deleteOneNode(head, del_node);\n    traverseList(head);\n    destoryALinklist(head);\n\n    return 0;\n}\n```\n输出结果\n![运行结果](https://blog-pics.nos-eastchina1.126.net/result.png)\n\n## 面试题：反转链表\n![面试题16](https://blog-pics.nos-eastchina1.126.net/jianzhioffer16.jpg)\n### 反转链表的方法\n很简单，把后一个节点的next指针指向前一个节点就好了；\n但是需要注意：\n* 反转之后头节点成为尾节点，后面是`NULL`；\n* 容易出现链表的断裂；\n* 当链表为空时，要做健壮性处理。\n\n综上，为了链表不断裂，需要三个指针来做这件事，一个指向当前节点，一个是它的上一节点，一个是下个节点，即`cur，pre，next`。我们有了这三个指针，接下来的事就好办了，只需从头遍历链表，把每个节点的next指向pre即可。\n代码如下：\n``` C\nLink *reverseList(Link *head)\n{\n    // first input check\n    if (head == NULL)\n        return NULL;\n\n    Link *cur = head;  // 当前节点指针\n    Link *next;        // 下一个节点指针\n    Link *pre = NULL;  // 前一个节点指针\n\n    while (cur != NULL)\n    {\n        if (cur->p_next == NULL)  // 到了尾节点\n        {\n            cur->p_next = pre;\n            break;\n        }\n        next = cur->p_next;\n        cur->p_next = pre;\n        pre = cur;\n        cur = next;\n    }\n    return cur;\n}\n```\n测试程序代码：\n``` C\nint main()\n{\n    int arr[5] = {1,2,3,4,5};\n    Link *head = createALinklist(arr, 5);\n    cout << \"before reverse:\" << endl;\n    traverseList(head);\n    Link *rhead = reverseList(head);\n    cout << \"after reverse:\" << endl;\n    traverseList(rhead);\n\n    return 0;\n}\n```\n运行结果：\n![反转链表运行结果](https://blog-pics.nos-eastchina1.126.net/result16.jpg)\n当问题不好解决时，不妨多用几个指针，也许就能豁然开朗。\n\n## 总结\n这些只是单链表最基础最简单的一些操作，实际工作中的链表应用会更复杂。不过只有把最基础的东西掌握好，才能向更强的地方迈进。\n还有一些如双向链表，循环链表等可能会在后续的学习中讲到。\n\n","slug":"single-linklist","published":1,"updated":"2019-01-16T03:00:37.242Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyoig8j0000apq0j0tl3ltyn","content":"<h2 id=\"为什么要说链表\"><a href=\"#为什么要说链表\" class=\"headerlink\" title=\"为什么要说链表\"></a>为什么要说链表</h2><p>链表这个词想必大家都很熟悉，但在实际工作中，我发现虽然经常会用到，但如果真是让自己从头开始造轮子，真正的从零开发，却还是会有种无从下手的感觉。如果你和我一样，请继续看下去。<br><a id=\"more\"></a><br>本文主要会讲链表的创建，销毁和遍历等链表的基本操作，并以几道面试题为例来做更具体的说明。</p>\n<h2 id=\"开始创建链表\"><a href=\"#开始创建链表\" class=\"headerlink\" title=\"开始创建链表\"></a>开始创建链表</h2><p>关于链表和数组的区别与各自的优缺点在此就不细说了，随便网上一抓一大把，今天主要弄些实在的，下面先从如何创建一个链表开始。<br>链表说白了就是从一个头指针开始，依次往后顺延连接的一个指针链。所以想获取一个链表只需要知道它的头指针即可，下面的是创建一个链表的代码。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> m_value;</span><br><span class=\"line\">    ListNode *p_next;</span><br><span class=\"line\">    ListNode(<span class=\"keyword\">int</span> x): m_value(x), p_next(<span class=\"literal\">NULL</span>) &#123; &#125;</span><br><span class=\"line\">&#125;Link;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 根据n个元素的数组arr创建一个链表，并返回链表头 */</span></span><br><span class=\"line\"><span class=\"function\">Link *<span class=\"title\">createALinklist</span><span class=\"params\">(<span class=\"keyword\">int</span> arr[], <span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    Link *head = <span class=\"keyword\">new</span> Link(arr[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    Link *cur_node = head;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cur_node-&gt;p_next = <span class=\"keyword\">new</span> Link(arr[i]);</span><br><span class=\"line\">        cur_node = cur_node-&gt;p_next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"遍历链表\"><a href=\"#遍历链表\" class=\"headerlink\" title=\"遍历链表\"></a>遍历链表</h2><p>知道了头指针，很方便地就可以遍历整个链表内容；<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 打印以head为头的链表节点信息 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">traverseList</span><span class=\"params\">(Link *head)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (head == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Link *cur_node = head;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (; cur_node != <span class=\"literal\">NULL</span>; cur_node = cur_node-&gt;p_next)</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; cur_node-&gt;m_value &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"销毁链表内容\"><a href=\"#销毁链表内容\" class=\"headerlink\" title=\"销毁链表内容\"></a>销毁链表内容</h2><p>在释放链表空间时要注意一个顺序问题，因为如果释放操作在指针指向下一个节点之前，那么就无法找到接下来的节点；故为了保证能正确释放，需要用到一个新指针，保存当前节点的位置。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 销毁以head为头的链表空间 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">destoryALinklist</span><span class=\"params\">(Link *head)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (head == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    Link *cur_node = head;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (cur_node != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Link *delNode = cur_node;</span><br><span class=\"line\">        cur_node = cur_node-&gt;p_next;  <span class=\"comment\">// 要注意删除前要先将当前节点指针指向下一个位置</span></span><br><span class=\"line\">        <span class=\"keyword\">delete</span> delNode;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"添加链表节点\"><a href=\"#添加链表节点\" class=\"headerlink\" title=\"添加链表节点\"></a>添加链表节点</h2><p>在链表的结尾添加一个新节点，这也属于链表的基本操作之一。<br>但需要注意的是：</p>\n<ul>\n<li>链表为空时，要直接把头节点指向新节点；</li>\n<li>要想在函数内部改变指针本身，需要用到二级指针</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 在链表结尾添加一个节点 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">addOneNodeToTail</span><span class=\"params\">(<span class=\"keyword\">int</span> item, Link **head)</span>  <span class=\"comment\">// **是为了要改变head指向的地址</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Link *cur = *head;</span><br><span class=\"line\">    Link *pnew = <span class=\"keyword\">new</span> Link(item);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pnew == <span class=\"literal\">NULL</span>)  <span class=\"comment\">// 内存申请失败</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cur == <span class=\"literal\">NULL</span>)  <span class=\"comment\">// 链表为空时</span></span><br><span class=\"line\">        *head = pnew;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (cur-&gt;p_next != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            cur = cur-&gt;p_next;</span><br><span class=\"line\">        cur-&gt;p_next = pnew;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"面试题：删除链表节点\"><a href=\"#面试题：删除链表节点\" class=\"headerlink\" title=\"面试题：删除链表节点\"></a>面试题：删除链表节点</h2><p><img src=\"https://blog-pics.nos-eastchina1.126.net/jianzhioffer13.png\" alt=\"面试题13\"></p>\n<h3 id=\"常规删除节点的方法\"><a href=\"#常规删除节点的方法\" class=\"headerlink\" title=\"常规删除节点的方法\"></a>常规删除节点的方法</h3><p>要想删除链表的一个节点，首先要遍历找到前一个节点的位置，然后再删除该节点；<br>如有链表<code>a--b--c--d--null</code>，要删除c节点，则需要遍历到c的前一个节点b，把b的next指针指向d，再释放c，即完成了删除操作；<br>但这样有n个节点的时间复杂度是O(n)，不符合题目的要求；</p>\n<h3 id=\"符合题目要求的方法\"><a href=\"#符合题目要求的方法\" class=\"headerlink\" title=\"符合题目要求的方法\"></a>符合题目要求的方法</h3><p>如想删除c节点，不一定要遍历到其前一个节点b，有了c节点的指针，可以很方便地获取到其下一个节点d，而删除操作就相当于是：</p>\n<ul>\n<li>把d节点的内容赋给c节点</li>\n<li>把c节点的next指针指向d的next</li>\n</ul>\n<p>以上操作就无需遍历到c的上一个节点，此操作的时间复杂度是O(1)，符合题目的要求；<br>但需要注意两种特殊情况：</p>\n<ol>\n<li>链表只有一个节点，此时操作就变成了把头节点置null，并释放空间；</li>\n<li>要删除节点是链表的最后一个节点，由于没有后一个节点，此时需用常规删除节点的方法进行删除；</li>\n</ol>\n<p>代码如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 删除指针指向的链表节点 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">deleteOneNode</span><span class=\"params\">(Link *head, Link *toBeDeleted)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!head || !toBeDeleted)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 链表只有一个节点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (head-&gt;p_next == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> toBeDeleted;</span><br><span class=\"line\">        toBeDeleted = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        head = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 要删除的节点是尾节点</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (toBeDeleted-&gt;p_next == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Link *cur_node = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (cur_node != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cur_node-&gt;p_next != toBeDeleted)</span><br><span class=\"line\">                cur_node = cur_node-&gt;p_next;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                cur_node -&gt;p_next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">                <span class=\"keyword\">delete</span> toBeDeleted;</span><br><span class=\"line\">                toBeDeleted = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 删除中间的节点</span></span><br><span class=\"line\">        toBeDeleted-&gt;m_value = toBeDeleted-&gt;p_next-&gt;m_value;</span><br><span class=\"line\">        toBeDeleted-&gt;p_next = toBeDeleted-&gt;p_next-&gt;p_next;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> toBeDeleted-&gt;p_next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>测试程序<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> arr[] = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;;</span><br><span class=\"line\">    Link *head = createALinklist(arr, <span class=\"number\">5</span>);</span><br><span class=\"line\">    Link *del_node = head;</span><br><span class=\"line\">    traverseList(head);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        del_node = del_node-&gt;p_next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    deleteOneNode(head, del_node);</span><br><span class=\"line\">    traverseList(head);</span><br><span class=\"line\">    destoryALinklist(head);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>输出结果<br><img src=\"https://blog-pics.nos-eastchina1.126.net/result.png\" alt=\"运行结果\"></p>\n<h2 id=\"面试题：反转链表\"><a href=\"#面试题：反转链表\" class=\"headerlink\" title=\"面试题：反转链表\"></a>面试题：反转链表</h2><p><img src=\"https://blog-pics.nos-eastchina1.126.net/jianzhioffer16.jpg\" alt=\"面试题16\"></p>\n<h3 id=\"反转链表的方法\"><a href=\"#反转链表的方法\" class=\"headerlink\" title=\"反转链表的方法\"></a>反转链表的方法</h3><p>很简单，把后一个节点的next指针指向前一个节点就好了；<br>但是需要注意：</p>\n<ul>\n<li>反转之后头节点成为尾节点，后面是<code>NULL</code>；</li>\n<li>容易出现链表的断裂；</li>\n<li>当链表为空时，要做健壮性处理。</li>\n</ul>\n<p>综上，为了链表不断裂，需要三个指针来做这件事，一个指向当前节点，一个是它的上一节点，一个是下个节点，即<code>cur，pre，next</code>。我们有了这三个指针，接下来的事就好办了，只需从头遍历链表，把每个节点的next指向pre即可。<br>代码如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Link *<span class=\"title\">reverseList</span><span class=\"params\">(Link *head)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// first input check</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (head == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    Link *cur = head;  <span class=\"comment\">// 当前节点指针</span></span><br><span class=\"line\">    Link *next;        <span class=\"comment\">// 下一个节点指针</span></span><br><span class=\"line\">    Link *pre = <span class=\"literal\">NULL</span>;  <span class=\"comment\">// 前一个节点指针</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (cur != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cur-&gt;p_next == <span class=\"literal\">NULL</span>)  <span class=\"comment\">// 到了尾节点</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            cur-&gt;p_next = pre;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        next = cur-&gt;p_next;</span><br><span class=\"line\">        cur-&gt;p_next = pre;</span><br><span class=\"line\">        pre = cur;</span><br><span class=\"line\">        cur = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cur;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>测试程序代码：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> arr[<span class=\"number\">5</span>] = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;;</span><br><span class=\"line\">    Link *head = createALinklist(arr, <span class=\"number\">5</span>);</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"before reverse:\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    traverseList(head);</span><br><span class=\"line\">    Link *rhead = reverseList(head);</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"after reverse:\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    traverseList(rhead);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行结果：<br><img src=\"https://blog-pics.nos-eastchina1.126.net/result16.jpg\" alt=\"反转链表运行结果\"><br>当问题不好解决时，不妨多用几个指针，也许就能豁然开朗。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>这些只是单链表最基础最简单的一些操作，实际工作中的链表应用会更复杂。不过只有把最基础的东西掌握好，才能向更强的地方迈进。<br>还有一些如双向链表，循环链表等可能会在后续的学习中讲到。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"为什么要说链表\"><a href=\"#为什么要说链表\" class=\"headerlink\" title=\"为什么要说链表\"></a>为什么要说链表</h2><p>链表这个词想必大家都很熟悉，但在实际工作中，我发现虽然经常会用到，但如果真是让自己从头开始造轮子，真正的从零开发，却还是会有种无从下手的感觉。如果你和我一样，请继续看下去。<br></p>","more":"<br>本文主要会讲链表的创建，销毁和遍历等链表的基本操作，并以几道面试题为例来做更具体的说明。<p></p>\n<h2 id=\"开始创建链表\"><a href=\"#开始创建链表\" class=\"headerlink\" title=\"开始创建链表\"></a>开始创建链表</h2><p>关于链表和数组的区别与各自的优缺点在此就不细说了，随便网上一抓一大把，今天主要弄些实在的，下面先从如何创建一个链表开始。<br>链表说白了就是从一个头指针开始，依次往后顺延连接的一个指针链。所以想获取一个链表只需要知道它的头指针即可，下面的是创建一个链表的代码。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> m_value;</span><br><span class=\"line\">    ListNode *p_next;</span><br><span class=\"line\">    ListNode(<span class=\"keyword\">int</span> x): m_value(x), p_next(<span class=\"literal\">NULL</span>) &#123; &#125;</span><br><span class=\"line\">&#125;Link;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 根据n个元素的数组arr创建一个链表，并返回链表头 */</span></span><br><span class=\"line\"><span class=\"function\">Link *<span class=\"title\">createALinklist</span><span class=\"params\">(<span class=\"keyword\">int</span> arr[], <span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    Link *head = <span class=\"keyword\">new</span> Link(arr[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    Link *cur_node = head;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cur_node-&gt;p_next = <span class=\"keyword\">new</span> Link(arr[i]);</span><br><span class=\"line\">        cur_node = cur_node-&gt;p_next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"遍历链表\"><a href=\"#遍历链表\" class=\"headerlink\" title=\"遍历链表\"></a>遍历链表</h2><p>知道了头指针，很方便地就可以遍历整个链表内容；<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 打印以head为头的链表节点信息 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">traverseList</span><span class=\"params\">(Link *head)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (head == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Link *cur_node = head;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (; cur_node != <span class=\"literal\">NULL</span>; cur_node = cur_node-&gt;p_next)</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; cur_node-&gt;m_value &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"销毁链表内容\"><a href=\"#销毁链表内容\" class=\"headerlink\" title=\"销毁链表内容\"></a>销毁链表内容</h2><p>在释放链表空间时要注意一个顺序问题，因为如果释放操作在指针指向下一个节点之前，那么就无法找到接下来的节点；故为了保证能正确释放，需要用到一个新指针，保存当前节点的位置。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 销毁以head为头的链表空间 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">destoryALinklist</span><span class=\"params\">(Link *head)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (head == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    Link *cur_node = head;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (cur_node != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Link *delNode = cur_node;</span><br><span class=\"line\">        cur_node = cur_node-&gt;p_next;  <span class=\"comment\">// 要注意删除前要先将当前节点指针指向下一个位置</span></span><br><span class=\"line\">        <span class=\"keyword\">delete</span> delNode;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"添加链表节点\"><a href=\"#添加链表节点\" class=\"headerlink\" title=\"添加链表节点\"></a>添加链表节点</h2><p>在链表的结尾添加一个新节点，这也属于链表的基本操作之一。<br>但需要注意的是：</p>\n<ul>\n<li>链表为空时，要直接把头节点指向新节点；</li>\n<li>要想在函数内部改变指针本身，需要用到二级指针</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 在链表结尾添加一个节点 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">addOneNodeToTail</span><span class=\"params\">(<span class=\"keyword\">int</span> item, Link **head)</span>  <span class=\"comment\">// **是为了要改变head指向的地址</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Link *cur = *head;</span><br><span class=\"line\">    Link *pnew = <span class=\"keyword\">new</span> Link(item);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pnew == <span class=\"literal\">NULL</span>)  <span class=\"comment\">// 内存申请失败</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cur == <span class=\"literal\">NULL</span>)  <span class=\"comment\">// 链表为空时</span></span><br><span class=\"line\">        *head = pnew;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (cur-&gt;p_next != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            cur = cur-&gt;p_next;</span><br><span class=\"line\">        cur-&gt;p_next = pnew;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"面试题：删除链表节点\"><a href=\"#面试题：删除链表节点\" class=\"headerlink\" title=\"面试题：删除链表节点\"></a>面试题：删除链表节点</h2><p><img src=\"https://blog-pics.nos-eastchina1.126.net/jianzhioffer13.png\" alt=\"面试题13\"></p>\n<h3 id=\"常规删除节点的方法\"><a href=\"#常规删除节点的方法\" class=\"headerlink\" title=\"常规删除节点的方法\"></a>常规删除节点的方法</h3><p>要想删除链表的一个节点，首先要遍历找到前一个节点的位置，然后再删除该节点；<br>如有链表<code>a--b--c--d--null</code>，要删除c节点，则需要遍历到c的前一个节点b，把b的next指针指向d，再释放c，即完成了删除操作；<br>但这样有n个节点的时间复杂度是O(n)，不符合题目的要求；</p>\n<h3 id=\"符合题目要求的方法\"><a href=\"#符合题目要求的方法\" class=\"headerlink\" title=\"符合题目要求的方法\"></a>符合题目要求的方法</h3><p>如想删除c节点，不一定要遍历到其前一个节点b，有了c节点的指针，可以很方便地获取到其下一个节点d，而删除操作就相当于是：</p>\n<ul>\n<li>把d节点的内容赋给c节点</li>\n<li>把c节点的next指针指向d的next</li>\n</ul>\n<p>以上操作就无需遍历到c的上一个节点，此操作的时间复杂度是O(1)，符合题目的要求；<br>但需要注意两种特殊情况：</p>\n<ol>\n<li>链表只有一个节点，此时操作就变成了把头节点置null，并释放空间；</li>\n<li>要删除节点是链表的最后一个节点，由于没有后一个节点，此时需用常规删除节点的方法进行删除；</li>\n</ol>\n<p>代码如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 删除指针指向的链表节点 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">deleteOneNode</span><span class=\"params\">(Link *head, Link *toBeDeleted)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!head || !toBeDeleted)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 链表只有一个节点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (head-&gt;p_next == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> toBeDeleted;</span><br><span class=\"line\">        toBeDeleted = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        head = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 要删除的节点是尾节点</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (toBeDeleted-&gt;p_next == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Link *cur_node = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (cur_node != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cur_node-&gt;p_next != toBeDeleted)</span><br><span class=\"line\">                cur_node = cur_node-&gt;p_next;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                cur_node -&gt;p_next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">                <span class=\"keyword\">delete</span> toBeDeleted;</span><br><span class=\"line\">                toBeDeleted = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 删除中间的节点</span></span><br><span class=\"line\">        toBeDeleted-&gt;m_value = toBeDeleted-&gt;p_next-&gt;m_value;</span><br><span class=\"line\">        toBeDeleted-&gt;p_next = toBeDeleted-&gt;p_next-&gt;p_next;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> toBeDeleted-&gt;p_next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>测试程序<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> arr[] = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;;</span><br><span class=\"line\">    Link *head = createALinklist(arr, <span class=\"number\">5</span>);</span><br><span class=\"line\">    Link *del_node = head;</span><br><span class=\"line\">    traverseList(head);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        del_node = del_node-&gt;p_next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    deleteOneNode(head, del_node);</span><br><span class=\"line\">    traverseList(head);</span><br><span class=\"line\">    destoryALinklist(head);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>输出结果<br><img src=\"https://blog-pics.nos-eastchina1.126.net/result.png\" alt=\"运行结果\"></p>\n<h2 id=\"面试题：反转链表\"><a href=\"#面试题：反转链表\" class=\"headerlink\" title=\"面试题：反转链表\"></a>面试题：反转链表</h2><p><img src=\"https://blog-pics.nos-eastchina1.126.net/jianzhioffer16.jpg\" alt=\"面试题16\"></p>\n<h3 id=\"反转链表的方法\"><a href=\"#反转链表的方法\" class=\"headerlink\" title=\"反转链表的方法\"></a>反转链表的方法</h3><p>很简单，把后一个节点的next指针指向前一个节点就好了；<br>但是需要注意：</p>\n<ul>\n<li>反转之后头节点成为尾节点，后面是<code>NULL</code>；</li>\n<li>容易出现链表的断裂；</li>\n<li>当链表为空时，要做健壮性处理。</li>\n</ul>\n<p>综上，为了链表不断裂，需要三个指针来做这件事，一个指向当前节点，一个是它的上一节点，一个是下个节点，即<code>cur，pre，next</code>。我们有了这三个指针，接下来的事就好办了，只需从头遍历链表，把每个节点的next指向pre即可。<br>代码如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Link *<span class=\"title\">reverseList</span><span class=\"params\">(Link *head)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// first input check</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (head == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    Link *cur = head;  <span class=\"comment\">// 当前节点指针</span></span><br><span class=\"line\">    Link *next;        <span class=\"comment\">// 下一个节点指针</span></span><br><span class=\"line\">    Link *pre = <span class=\"literal\">NULL</span>;  <span class=\"comment\">// 前一个节点指针</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (cur != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cur-&gt;p_next == <span class=\"literal\">NULL</span>)  <span class=\"comment\">// 到了尾节点</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            cur-&gt;p_next = pre;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        next = cur-&gt;p_next;</span><br><span class=\"line\">        cur-&gt;p_next = pre;</span><br><span class=\"line\">        pre = cur;</span><br><span class=\"line\">        cur = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cur;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>测试程序代码：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> arr[<span class=\"number\">5</span>] = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;;</span><br><span class=\"line\">    Link *head = createALinklist(arr, <span class=\"number\">5</span>);</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"before reverse:\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    traverseList(head);</span><br><span class=\"line\">    Link *rhead = reverseList(head);</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"after reverse:\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    traverseList(rhead);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行结果：<br><img src=\"https://blog-pics.nos-eastchina1.126.net/result16.jpg\" alt=\"反转链表运行结果\"><br>当问题不好解决时，不妨多用几个指针，也许就能豁然开朗。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>这些只是单链表最基础最简单的一些操作，实际工作中的链表应用会更复杂。不过只有把最基础的东西掌握好，才能向更强的地方迈进。<br>还有一些如双向链表，循环链表等可能会在后续的学习中讲到。</p>"},{"title":"start from now","date":"2018-10-29T02:55:00.000Z","_content":"今天开始自己职业生涯中的第一篇博客，从无到有。\n<!-- more -->\n\n不想在各种大型博客网站混入其中，写博客的目的就是想把学到的知识再次巩固与记忆，今后方便查找。之前一直都是用word和onenote等软件做笔记的，虽然该记的内容都记下来了，覆盖的范围挺全的，但这个功能仅限于需要回忆时才会翻开笔记查看之前写的内容；而多数的笔记是出于一种放置的状态的，并没有起到能及时复习的实质性作用。\n\n所以我打算从今天起开始写自己的博客。\n\n写博客和记笔记的区别在于：笔记是写给自己看的，博客是给所有人看的；所以在写博客时就会强迫自己更注意措辞，以一种更能让人理解的方式表达，同时，自己也需要真正的吃透一个知识点才能给别人讲清楚，所以在提升内容质量的同时还能训练自己的文字表达能力；在日后的学习与复习中，也能更快的回忆起之前的学习成果，何乐而不为呢？\n\nSo, why not start from now? \n","source":"_posts/start-from-now.md","raw":"---\ntitle: start from now\ndate: 2018-10-29 10:55:00\ntags: 杂谈\ncategories: 心路历程\n---\n今天开始自己职业生涯中的第一篇博客，从无到有。\n<!-- more -->\n\n不想在各种大型博客网站混入其中，写博客的目的就是想把学到的知识再次巩固与记忆，今后方便查找。之前一直都是用word和onenote等软件做笔记的，虽然该记的内容都记下来了，覆盖的范围挺全的，但这个功能仅限于需要回忆时才会翻开笔记查看之前写的内容；而多数的笔记是出于一种放置的状态的，并没有起到能及时复习的实质性作用。\n\n所以我打算从今天起开始写自己的博客。\n\n写博客和记笔记的区别在于：笔记是写给自己看的，博客是给所有人看的；所以在写博客时就会强迫自己更注意措辞，以一种更能让人理解的方式表达，同时，自己也需要真正的吃透一个知识点才能给别人讲清楚，所以在提升内容质量的同时还能训练自己的文字表达能力；在日后的学习与复习中，也能更快的回忆起之前的学习成果，何乐而不为呢？\n\nSo, why not start from now? \n","slug":"start-from-now","published":1,"updated":"2018-11-02T02:20:09.833Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyoig8j2000epq0jj3lnd269","content":"<p>今天开始自己职业生涯中的第一篇博客，从无到有。<br><a id=\"more\"></a></p>\n<p>不想在各种大型博客网站混入其中，写博客的目的就是想把学到的知识再次巩固与记忆，今后方便查找。之前一直都是用word和onenote等软件做笔记的，虽然该记的内容都记下来了，覆盖的范围挺全的，但这个功能仅限于需要回忆时才会翻开笔记查看之前写的内容；而多数的笔记是出于一种放置的状态的，并没有起到能及时复习的实质性作用。</p>\n<p>所以我打算从今天起开始写自己的博客。</p>\n<p>写博客和记笔记的区别在于：笔记是写给自己看的，博客是给所有人看的；所以在写博客时就会强迫自己更注意措辞，以一种更能让人理解的方式表达，同时，自己也需要真正的吃透一个知识点才能给别人讲清楚，所以在提升内容质量的同时还能训练自己的文字表达能力；在日后的学习与复习中，也能更快的回忆起之前的学习成果，何乐而不为呢？</p>\n<p>So, why not start from now? </p>\n","site":{"data":{}},"excerpt":"<p>今天开始自己职业生涯中的第一篇博客，从无到有。<br></p>","more":"<p></p>\n<p>不想在各种大型博客网站混入其中，写博客的目的就是想把学到的知识再次巩固与记忆，今后方便查找。之前一直都是用word和onenote等软件做笔记的，虽然该记的内容都记下来了，覆盖的范围挺全的，但这个功能仅限于需要回忆时才会翻开笔记查看之前写的内容；而多数的笔记是出于一种放置的状态的，并没有起到能及时复习的实质性作用。</p>\n<p>所以我打算从今天起开始写自己的博客。</p>\n<p>写博客和记笔记的区别在于：笔记是写给自己看的，博客是给所有人看的；所以在写博客时就会强迫自己更注意措辞，以一种更能让人理解的方式表达，同时，自己也需要真正的吃透一个知识点才能给别人讲清楚，所以在提升内容质量的同时还能训练自己的文字表达能力；在日后的学习与复习中，也能更快的回忆起之前的学习成果，何乐而不为呢？</p>\n<p>So, why not start from now? </p>"}],"PostAsset":[{"_id":"source/_posts/BST/BST测试程序执行结果.jpg","slug":"BST测试程序执行结果.jpg","post":"cjyoig8ip0000pq0jfyagvm6d","modified":0,"renderable":0},{"_id":"source/_posts/BST/satuation1.png","slug":"satuation1.png","post":"cjyoig8ip0000pq0jfyagvm6d","modified":0,"renderable":0},{"_id":"source/_posts/BST/satuation2-1.png","slug":"satuation2-1.png","post":"cjyoig8ip0000pq0jfyagvm6d","modified":0,"renderable":0},{"_id":"source/_posts/BST/satuation2-2.png","slug":"satuation2-2.png","post":"cjyoig8ip0000pq0jfyagvm6d","modified":0,"renderable":0},{"_id":"source/_posts/BST/satuation3-1.png","slug":"satuation3-1.png","post":"cjyoig8ip0000pq0jfyagvm6d","modified":0,"renderable":0},{"_id":"source/_posts/BST/satuation3-2.png","slug":"satuation3-2.png","post":"cjyoig8ip0000pq0jfyagvm6d","modified":0,"renderable":0},{"_id":"source/_posts/BST/一个二叉搜索树.jpg","slug":"一个二叉搜索树.jpg","post":"cjyoig8ip0000pq0jfyagvm6d","modified":0,"renderable":0}],"PostCategory":[{"post_id":"cjyoig8ip0000pq0jfyagvm6d","category_id":"cjyoig8iu0002pq0jmon191or","_id":"cjyoig8j1000bpq0jy1z885uz"},{"post_id":"cjyoig8is0001pq0jcvij0f55","category_id":"cjyoig8iy0007pq0jauebuvh5","_id":"cjyoig8j4000gpq0jh4kxqm97"},{"post_id":"cjyoig8iv0004pq0j5qoobkwm","category_id":"cjyoig8iy0007pq0jauebuvh5","_id":"cjyoig8j4000jpq0j61fdwxpc"},{"post_id":"cjyoig8iw0005pq0jqru6xs2y","category_id":"cjyoig8j4000fpq0jgkxfrxfy","_id":"cjyoig8j5000opq0jq9yexga2"},{"post_id":"cjyoig8iz0009pq0jlbq2512k","category_id":"cjyoig8j4000lpq0jn16dbjll","_id":"cjyoig8j6000rpq0jegiyy2lx"},{"post_id":"cjyoig8j0000apq0j0tl3ltyn","category_id":"cjyoig8j5000ppq0j24rifxzl","_id":"cjyoig8j6000wpq0jjnu6rfrw"},{"post_id":"cjyoig8j2000epq0jj3lnd269","category_id":"cjyoig8j6000spq0j1s45w11b","_id":"cjyoig8j7000zpq0j6q3mnwxr"}],"PostTag":[{"post_id":"cjyoig8ip0000pq0jfyagvm6d","tag_id":"cjyoig8iv0003pq0jmz300wlp","_id":"cjyoig8j4000ipq0jhfrt94yq"},{"post_id":"cjyoig8ip0000pq0jfyagvm6d","tag_id":"cjyoig8iz0008pq0jkrcv252a","_id":"cjyoig8j4000kpq0jvxnw6vnj"},{"post_id":"cjyoig8ip0000pq0jfyagvm6d","tag_id":"cjyoig8j1000dpq0j3xfvdgzr","_id":"cjyoig8j5000npq0jp28x0e9p"},{"post_id":"cjyoig8is0001pq0jcvij0f55","tag_id":"cjyoig8j4000hpq0j7zp1rcsx","_id":"cjyoig8j6000upq0j2bmb6x0q"},{"post_id":"cjyoig8is0001pq0jcvij0f55","tag_id":"cjyoig8j5000mpq0jn4b2f9b1","_id":"cjyoig8j6000vpq0jfif2zr2v"},{"post_id":"cjyoig8is0001pq0jcvij0f55","tag_id":"cjyoig8iv0003pq0jmz300wlp","_id":"cjyoig8j7000ypq0jjd9neman"},{"post_id":"cjyoig8iv0004pq0j5qoobkwm","tag_id":"cjyoig8j6000tpq0jvxet1i50","_id":"cjyoig8j70012pq0jsgd6nrec"},{"post_id":"cjyoig8iv0004pq0j5qoobkwm","tag_id":"cjyoig8j5000mpq0jn4b2f9b1","_id":"cjyoig8j70013pq0j2jxch6bj"},{"post_id":"cjyoig8iv0004pq0j5qoobkwm","tag_id":"cjyoig8j70010pq0j7ac0awd5","_id":"cjyoig8j80015pq0j6jofpj8g"},{"post_id":"cjyoig8iw0005pq0jqru6xs2y","tag_id":"cjyoig8j70011pq0jb22g66rj","_id":"cjyoig8j80016pq0j4t7e0ofm"},{"post_id":"cjyoig8iz0009pq0jlbq2512k","tag_id":"cjyoig8j70014pq0j8spevds5","_id":"cjyoig8j90018pq0jxfm0gohg"},{"post_id":"cjyoig8j0000apq0j0tl3ltyn","tag_id":"cjyoig8j5000mpq0jn4b2f9b1","_id":"cjyoig8j9001bpq0jnd0iuvox"},{"post_id":"cjyoig8j0000apq0j0tl3ltyn","tag_id":"cjyoig8iv0003pq0jmz300wlp","_id":"cjyoig8j9001cpq0jpw0n0wuk"},{"post_id":"cjyoig8j0000apq0j0tl3ltyn","tag_id":"cjyoig8j90019pq0jrp9gxarf","_id":"cjyoig8j9001dpq0ji37yqdou"},{"post_id":"cjyoig8j2000epq0jj3lnd269","tag_id":"cjyoig8j9001apq0j8q9ytyg1","_id":"cjyoig8ja001epq0jqkdq3qzb"}],"Tag":[{"name":"数据结构","_id":"cjyoig8iv0003pq0jmz300wlp"},{"name":"BST","_id":"cjyoig8iz0008pq0jkrcv252a"},{"name":"二叉搜索树","_id":"cjyoig8j1000dpq0j3xfvdgzr"},{"name":"有环单链表","_id":"cjyoig8j4000hpq0j7zp1rcsx"},{"name":"算法","_id":"cjyoig8j5000mpq0jn4b2f9b1"},{"name":"动态规划","_id":"cjyoig8j6000tpq0jvxet1i50"},{"name":"最长公共子序列","_id":"cjyoig8j70010pq0j7ac0awd5"},{"name":"诗歌/感悟/人生","_id":"cjyoig8j70011pq0jb22g66rj"},{"name":"动态内存/栈/堆","_id":"cjyoig8j70014pq0j8spevds5"},{"name":"单链表","_id":"cjyoig8j90019pq0jrp9gxarf"},{"name":"杂谈","_id":"cjyoig8j9001apq0j8q9ytyg1"}]}}