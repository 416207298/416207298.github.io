---
title: 重新思考内存申请
date: 2019-03-15 14:48:59
tags: 动态内存/栈/堆
categories: 
- 工作
---
## 前言
最近在一个项目中用C语言做一个restful服务的桥接器，具体功能就是把Java端发过来的请求报文解析，再用解析出的内容调用C底层相应的接口，最后把C接口返回的信息再发给Java端。
测试时发现，多数接口的请求能正常接收到返回信息，但某些请求报文特别长的接口，就无法正常获取返回报文。查了代码发现是**接收报文变量**的长度定义过短导致程序提前退出了。我便把**接收报文的变量**变为了动态申请内存，申请了1MB的内存，结尾处再释放掉，这样改过之后，程序没有提前退出，却出现了段错误。查了半天，最后发现问题出在一个调试语句上，那里还是用的**栈内存**申请，在把最大报文长度限制变成1MB之后，加上调用底层C接口中申请的**栈地址空间**,超过了linux栈空间的限制，导致**内存溢出**了。
<!-- more -->
借此机会详细的回顾一下linux下的内存申请相关的内容。

## 栈内存申请
这是系统分配内存的方式，也是最基本的一种内存申请方式，如要申请**十个字节**的空间，并全部赋值为尾零：
``` C
char str[10] = {0};
```
这样就在栈上申请到了**10个字节**的空间，这一部分空间是无需程序员手动释放的，在程序执行结束或一个代码块结束后会由操作系统自动收回。其操作方式类似于数据结构的**栈**，只要栈剩余的空间大于所申请的空间，系统将为程序提供内存，否则将报异常提示栈溢出。
在linux系统下，查看系统栈的空间容量可以用`ulimit -a`或`limit`直接查看：

| ![ulimit -a](https://blog-pics.nos-eastchina1.126.net/rethinkOfMelloc/ulimit%20-a%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C.jpg) |  ![limit](https://blog-pics.nos-eastchina1.126.net/rethinkOfMelloc/limit%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C.jpg)| 
| --- | --- |

可以看到，在mac系统下，**stacksize**的大小是8MB，即8 \* 1024 \* 1024个字节
所以，这样最多申请的占内存空间为：`char str[8192 * 1024]`，超过这个数字就会报段错误，也就是由栈内存溢出导致的。
测试一下，
``` C
#define MAXLEN 8192 * 1023 

int main() {
    char str[MAXLEN];
    return 0;
}
```
当把**MAXLEN**赋值为8192 \* 1023时，程序还能正常运行，但改为8192 \* 1024时就**段错误**了，可能包含几KB的栈信息数据。由此证明了栈空间确实是8MB（软限制），可以通过`ulimit -s`命令临时改变栈空间的大小，突破软限制。

## 堆内存申请
一般由程序员分配和释放，程序员若不释放，程序结束时可能由OS回收。但它与数据结构的堆是两码事，分配方式类似于数据结构的**链表**。
申请一个10字节的空间书写如下：
``` C
char *str = (char *)malloc(10);
```
或
``` C
char *str = (char *)calloc(1, 10);
```
在堆上的内存申请，默认是没有**软限制**的，只依赖系统**硬限制**，故在申请**大空间**时需要用**动态申请**的方法，不过需要注意的是在用完该内存后要及时释放，否则会导致内存泄露而使内存耗尽。下面就来说一下内存释放的方法。

## 内存释放
堆上内存需要手动释放，方法如下：
``` C
if (str)
    free(str);
str = NULL;
```
一般习惯用宏来实现：
``` C
#define dataFree(str) if(str){free(str);str=NULL;}
```
最后把`str`指针指向`NULL`的原因是，`free`操作仅释放了`str`指向的内存空间，而不包括`str`指针本身，`str`仍旧指向那片内存地址，只不过是未申请的了，如果后面的程序又有操作到了`str`指针，将会产生不可预知的错误，故要将其指向`NULL`。

## 总结
常常说，细节决定成败。这次犯的错误不是什么大错误，不过却造成了整个桥接器无法使用。在考虑问题的时候一定要周全，不但要保证自己写的模块没有问题，还要考虑到模块与模块之间交互的过程中可能会出现哪些问题。就像这次的内存溢出，自己这里申请1MB是没问题的，但加上其他模块的就超出了系统最大限制了，当然别人的模块也要改，但自己这里一定要足够健壮。
